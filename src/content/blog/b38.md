---
title: PowerShell Engine - Frontend / Forms [1]
description: Frontend issues specifically with webform creation.
pubDate: Sept 11 2024
heroImage: /public/img/elements.png
tags: ['Orchestration', 'JS', 'Forms', 'JSON', 'React','JSONSchema','Components']
categories: ['Automation']
---

This was the section I was actually dreading the most. I can do JS/HTML/CS/Framworker/React/Vue etc. I like Astro though. It's just not something I'm particularly enthusiastic about.

So as part of the workflow I want to introduce forms during the workflow so that the input variables can be passed etc.

After some R&D into packages, I am using anything that follows the JSON schema for forms.

## Components

For the `/formbuilder` page it will comprise of several components.

+ Collapsable left sidebar, that indexes and searchs for forms.
+ Main drag & drop form builder with a top bar showing options to 'Save','Versions','Properties','Used by','Close','Download'
+ A right hand sidebar named 'Toolbox(searchable)', this showcases all of the drag and drop elements that can be used.

---------------

## FormBuilder component

```jsx
import React, { useState } from 'react';
import Toolbox from './Toolbox';
import FormPreview from './FormPreview';
import ElementEditor from './ElementEditor';
import NewFormModal from './NewFormModal';

const FormBuilder = () => {
  const [forms, setForms] = useState([]);
  const [currentForm, setCurrentForm] = useState(null);
  const [selectedElement, setSelectedElement] = useState(null);
  const [showNewFormModal, setShowNewFormModal] = useState(false);

  const addForm = (formData) => {
    setForms([...forms, { ...formData, elements: [] }]);
    setCurrentForm(formData);
  };

  const addElement = (elementType) => {
    const newElement = {
      type: elementType,
      id: Date.now(),
      label: `New ${elementType}`,
      conditions: []
    };
    setCurrentForm({
      ...currentForm,
      elements: [...currentForm.elements, newElement]
    });
  };

  const updateElement = (updatedElement) => {
    setCurrentForm({
      ...currentForm,
      elements: currentForm.elements.map(el => 
        el.id === updatedElement.id ? updatedElement : el
      )
    });
  };

  return (
    <div className="form-builder">
      <header>
        <button onClick={() => setShowNewFormModal(true)}>New Form</button>
      </header>
      <div className="main-content">
        <Toolbox onAddElement={addElement} />
        <FormPreview 
          form={currentForm} 
          onSelectElement={setSelectedElement} 
        />
        {selectedElement && (
          <ElementEditor 
            element={selectedElement} 
            onUpdateElement={updateElement}
            allElements={currentForm.elements}
          />
        )}
      </div>
      {showNewFormModal && (
        <NewFormModal 
          onSubmit={addForm} 
          onClose={() => setShowNewFormModal(false)} 
        />
      )}
    </div>
  );
};

export default FormBuilder;
```

**Toolbox component:**

```jsx
import React from 'react';
import { Draggable, Droppable } from 'react-beautiful-dnd';

const Toolbox = ({ onAddElement }) => {
  const elements = [
    { type: 'form_selection',label 'Form Section'},
    { type: 'header_text', label 'Header Text'},
    { type: 'paragraph', label 'Paragraph'},
    { type: 'line_break',label: 'Line Break'},
    {type: 'dropdown', label: 'Dropdown'},
    {type: 'tags', label: 'Tags'},
    {type: 'checkboxes', label: 'Checkboxes'},
    {type: 'multiple_choice', label: 'Multiple Choice'},
    {type: 'action', label: 'Action Buttons'},
    {type: 'text', label: 'Text Input'},
    {type: 'password', label: 'Password'},
    {type: 'multi_list', label: 'Multiple Listbox'},
    {type: 'number', label: 'Number Input'},
    {type: 'table', label: 'Table Format'},
    {type: 'editable_table', label: 'Editable Table Format'},
    {type: 'treeview', label: 'Tree View'},
    {type: 'multi_line', label: 'Multi-line Input'},
    {type: 'rtf', label: 'Rich Text Editor'},
    {type: 'autocomplete_text', label: 'Auto Complete Text box'},
    {type: 'date', label: 'Date'},
    {type: 'date_pickertz', label: 'Date Picker Time Zone'}
  ];

  return (
    <div className="toolbox">
      <h3>Toolbox</h3>
      <input type="text" placeholder="Filter..." />
      <Droppable droppableId="toolbox" isDropDisabled={true}>
        {(provided) => (
          <div {...provided.droppableProps} ref={provided.innerRef}>
            {elements.map((element, index) => (
              <Draggable key={element.type} draggableId={element.type} index={index}>
                {(provided) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                    onClick={() => onAddElement(element.type)}
                  >
                    {element.label}
                  </div>
                )}
              </Draggable>
            ))}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    </div>
  );
};

export default Toolbox;
```

**FormPreview component:**

```jsx
import React from 'react';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';


const ElementPreview = ({ element, formValues }) => {
  const shouldDisplay = element.conditions.every(condition => {
    const fieldValue = formValues[condition.field];
    switch (condition.operator) {
      case '==': return fieldValue == condition.value;
      case '!=': return fieldValue != condition.value;
      case '>': return fieldValue > condition.value;
      case '<': return fieldValue < condition.value;
      default: return true;
    }
  });

  if (!shouldDisplay) return null;

  // Render different element types based on their properties
  switch (element.type) {
    case 'NumberInput':
      return <input type="number" placeholder={element.placeholder} />;
    case 'MultiLineInput':
      return <textarea placeholder={element.placeholder} />;
    // Add cases for other element types
    default:
      return <div>{element.label}</div>;
  }
};

const FormPreview = ({ form, onSelectElement, onReorderElements }) => {
  if (!form) return <div>No form selected</div>;

  const onDragEnd = (result) => {
    if (!result.destination) return;
    onReorderElements(result.source.index, result.destination.index);
  };

  return (
    <div className="form-preview">
      <h2>{form.name}</h2>
      <DragDropContext onDragEnd={onDragEnd}>
        <Droppable droppableId="form-elements">
          {(provided) => (
            <div {...provided.droppableProps} ref={provided.innerRef}>
              {form.elements.map((element, index) => (
                <Draggable key={element.id} draggableId={element.id.toString()} index={index}>
                  {(provided) => (
                    <div
                      ref={provided.innerRef}
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      onClick={() => onSelectElement(element)}
                    >
                      <ElementPreview element={element} />
                    </div>
                  )}
                </Draggable>
              ))}
              {provided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    </div>
  );
};

const ElementPreview = ({ element }) => {
  // Render different element types based on their properties
  switch (element.type) {
    case 'NumberInput':
      return <input type="number" placeholder={element.placeholder} />;
    case 'MultiLineInput':
      return <textarea placeholder={element.placeholder} />;
    // Add cases for other element types
    default:
      return <div>{element.label}</div>;
  }
};

export default FormPreview;
```

FormProperties component

```jsx
import React from 'react';

const FormProperties = ({ selectedElement, onUpdateElement }) => {
  if (!selectedElement) return null;

  const handleChange = (e) => {
    const { name, value } = e.target;
    onUpdateElement({ ...selectedElement, [name]: value });
  };

  return (
    <div className="form-properties">
      <h3>Edit: {selectedElement.type}</h3>
      <label>
        Reference Name (Orchestrator Package Use):
        <input
          name="referenceName"
          value={selectedElement.referenceName || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Default value:
        <input
          name="defaultValue"
          value={selectedElement.defaultValue || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Placeholder Text:
        <input
          name="placeholder"
          value={selectedElement.placeholder || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        RegEx:
        <input
          name="regex"
          value={selectedElement.regex || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Style:
        <select
          name="style"
          value={selectedElement.style || 'None'}
          onChange={handleChange}
        >
          <option value="None">None</option>
          <option value="Full Width">Full Width</option>
          {/* Add more style options */}
        </select>
      </label>
      <label>
        Display Label:
        <input
          name="label"
          value={selectedElement.label || ''}
          onChange={handleChange}
        />
      </label>
      {/* Add more properties based on element type */}
    </div>
  );
};

export default FormProperties;
```

**Element Editor:**
```jsx
import React, { useState } from 'react';

const ElementEditor = ({ element, onUpdateElement, allElements }) => {
  const [editedElement, setEditedElement] = useState(element);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setEditedElement({ ...editedElement, [name]: value });
  };

  const handleConditionChange = (index, field, value) => {
    const newConditions = [...editedElement.conditions];
    newConditions[index] = { ...newConditions[index], [field]: value };
    setEditedElement({ ...editedElement, conditions: newConditions });
  };

  const addCondition = () => {
    setEditedElement({
      ...editedElement,
      conditions: [...editedElement.conditions, { field: '', operator: '==', value: '' }]
    });
  };

  const removeCondition = (index) => {
    const newConditions = editedElement.conditions.filter((_, i) => i !== index);
    setEditedElement({ ...editedElement, conditions: newConditions });
  };

  const saveChanges = () => {
    onUpdateElement(editedElement);
  };

  return (
    <div className="element-editor">
      <h3>Edit: {editedElement.type}</h3>
      <label>
        Reference Name:
        <input
          name="referenceName"
          value={editedElement.referenceName || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Label:
        <input
          name="label"
          value={editedElement.label || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Placeholder:
        <input
          name="placeholder"
          value={editedElement.placeholder || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Default Value:
        <input
          name="defaultValue"
          value={editedElement.defaultValue || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        RegEx:
        <input
          name="regex"
          value={editedElement.regex || ''}
          onChange={handleChange}
        />
      </label>
      <label>
        Style:
        <select
          name="style"
          value={editedElement.style || 'None'}
          onChange={handleChange}
        >
          <option value="None">None</option>
          <option value="Full Width">Full Width</option>
        </select>
      </label>

      <h4>Display Conditions</h4>
      {editedElement.conditions.map((condition, index) => (
        <div key={index} className="condition">
          <select
            value={condition.field}
            onChange={(e) => handleConditionChange(index, 'field', e.target.value)}
          >
            <option value="">Select Field</option>
            {allElements.map(el => (
              <option key={el.id} value={el.referenceName}>{el.label}</option>
            ))}
          </select>
          <select
            value={condition.operator}
            onChange={(e) => handleConditionChange(index, 'operator', e.target.value)}
          >
            <option value="==">Equals</option>
            <option value="!=">Not Equals</option>
            <option value=">">Greater Than</option>
            <option value="<">Less Than</option>
          </select>
          <input
            type="text"
            value={condition.value}
            onChange={(e) => handleConditionChange(index, 'value', e.target.value)}
            placeholder="Value"
          />
          <button onClick={() => removeCondition(index)}>Remove</button>
        </div>
      ))}
      <button onClick={addCondition}>Add Condition</button>

      <button onClick={saveChanges}>Save Changes</button>
    </div>
  );
};

export default ElementEditor;
```

**NewFormModal:**
```jsx
import React, { useState } from 'react';

const NewFormModal = ({ onSubmit, onClose }) => {
  const [formData, setFormData] = useState({
    name: '',
    staticName: '',
    goButton: 'Enabled',
    readOnly: 'No',
    description: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formData);
    onClose();
  };

  return (
    <div className="modal">
      <h2>New Form</h2>
      <form onSubmit={handleSubmit}>
        <label>
          Name:
          <input
            name="name"
            value={formData.name}
            onChange={handleChange}
            placeholder="Human readable name"
          />
        </label>
        <label>
          Static Name:
          <input
            name="staticName"
            value={formData.staticName}
            onChange={handleChange}
            placeholder="e.g. new_user_form"
          />
        </label>
        <label>
          Go Button:
          <select name="goButton" value={formData.goButton} onChange={handleChange}>
            <option value="Enabled">Enabled</option>
            <option value="Disabled">Disabled</option>
          </select>
        </label>
        <label>
          Read Only:
          <select name="readOnly" value={formData.readOnly} onChange={handleChange}>
            <option value="Yes">Yes</option>
            <option value="No">No</option>
          </select>
        </label>
        <label>
          Description:
          <textarea
            name="description"
            value={formData.description}
            onChange={handleChange}
            placeholder="Describe the form and its purpose"
          />
        </label>
        <button type="submit">Create</button>
        <button type="button" onClick={onClose}>Cancel</button>
      </form>
    </div>
  );
};

export default NewFormModal;
```

JSON schema generation
```jsx
const generateJSONSchema = (form) => {
  return {
    type: 'object',
    properties: form.elements.reduce((acc, element) => {
      acc[element.referenceName] = {
        type: element.type,
        title: element.label,
        default: element.defaultValue,
        placeholder: element.placeholder,
        pattern: element.regex,
        // Add more properties based on element type
      };
      return acc;
    }, {}),
  };
};
```

**export functionality**
```jsx
const exportJSON = (form) => {
  const schema = generateJSONSchema(form);
  const jsonString = JSON.stringify(schema, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${form.staticName}.json`;
  a.click();
};
```


The code structure adheres to the overall layout I have in my head. Here are how the components correspond to the layout:

1. Left Sidebar (Forms List):
This is represented by a separate component (not explicitly shown in the code snippets) that would display the list of forms. In the image, it shows "AD Terminate User Properties Form", "AD User Details Properties Form", etc.

2. Main Content Area:
This is where the FormPreview component would be rendered, showing the current form being edited. In the image, it's displaying the "Active Directory Properties" form.

3. Right Sidebar (Toolbox):
This is represented by the Toolbox component, which lists all the available form elements that can be added to the form. In the image, it shows elements like "Form Section", "Header Text", "Paragraph", etc.

4. Top Bar:
The top bar with "Save", "Versions", "Properties", etc., would be part of the main FormBuilder component's layout.

5. Element Editor:
When an element is selected in the FormPreview, the ElementEditor component would appear, likely replacing the Toolbox or appearing as a modal.


I still need to do the following for beta buxxing it to tests:

1. Implement forms list component for left sidebar
2. Add the top bar with action buttons in formbuilder
3. Style all the components
4. Implement/Test various functionality.