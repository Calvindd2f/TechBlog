---
title: PowerShell Execution Engine - Binary Packager
description: PowerShell Execution Engine for future workflow orchestration packaged into an `exe`. This is the source code for how the packager / installer was created.
pubDate: Sept 09 2024
heroImage: /public/img/packager.jpg
tags: ['Orchestration', 'C#', 'Windows Service', 'Packaging', 'Binary', 'Compression', 'Installer']
categories: ['Automation']
---

This one is in for the longhaul so lets just get started.
In the root of the submodule repository we are going to create the requisite files used during the creation process.

For the projects root directory `/`:

```txt
AgentInstallController.cs
AgentServiceInstallerEmbeddedConfig.cs
AgentInstallerConfigUtil.cs
AgentInstallException.cs
ExceptionLoggingUtil.cs
Installer.cs
LogUtil.cs
Program.cs
RecoveryOptionsElement.cs
ServiceInstaller.cs
ServiceState.cs
ScmAccessRights.cs
ServiceAccessRights.cs
ServiceBootFlag.cs
ServiceControl.cs
ServiceError.cs
ServiceRecoveryAction.cs
ServiceRecoveryOptions.cs
```

In the `Properties` directory/namespace:

```txt
Properties.Resources
Properties.Settings
```

In the `Models` directory/namespace:

```txt
Models.DataDirectory.cs
Models.FileHeader.cs
Models.OptionalHeader.cs
```

In the `Helpers` directory/namespace:

```txt
Helpers.ByteHelper.cs
Helpers.ZipArchiveExtensions.cs
Helpers.PE32Binary.cs
```

Other important types:

```txt
SC_ACTION_TYPE
SC_ACTION
SERVICE_FAILURE_ACTIONS
SERVICE_STATUS
ConfigUtil
ExceptionLoggingUtil
LogUtil
```

---

#### AgentInstallController.cs

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.IO.Pipes;
using System.Management;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using ServiceInstaller.Helpers;
using ServiceInstaller.Properties;

namespace ServiceInstaller
{
	public class AgentInstallController
	{
		public static bool CheckIfInstalled()
		{
			return File.Exists(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "OrchestratorAgent", "OrchestratorAgent.exe"));
		}

		private static void Install_StopService()
		{
			try
			{
				ServiceState serviceStatus = ServiceInstaller.GetServiceStatus("OrchestratorAgent");
				if (serviceStatus != ServiceState.Stopped && serviceStatus != ServiceState.NotFound)
				{
					ServiceInstaller.StopService("OrchestratorAgent");
					LogUtil.LogInfo("Service has been stopped.", "");
				}
				else
				{
					LogUtil.LogInfo("Agent service does not need to be stopped, service state: " + Enum.GetName(typeof(ServiceState), serviceStatus), "");
				}
			}
			catch (Exception)
			{
				throw new AgentInstallException("Failed to stop existing installed service. You may need to try again in a few seconds.");
			}
		}

		private static void Install_PrepareAgentDirectory(string agentInstallDir, string agentUpdateBackupDir)
		{
			try
			{
				if (Directory.Exists(agentInstallDir))
				{
					if (Directory.Exists(agentUpdateBackupDir))
					{
						try
						{
							LogUtil.LogInfo("Previous agent backup directory detected, deleting agent backup directory.", "");
							Directory.Delete(agentUpdateBackupDir, true);
						}
						catch (Exception)
						{
							throw new Exception("Failed to delete the backup directory in the installation path. Perhaps there is a file open?");
						}
					}
					IEnumerable<string> enumerable = Directory.EnumerateFiles(agentInstallDir, "*.dll", SearchOption.TopDirectoryOnly);
					IEnumerable<string> enumerable2 = Directory.EnumerateFiles(agentInstallDir, "*.exe", SearchOption.TopDirectoryOnly);
					try
					{
						LogUtil.LogInfo("Create new update backup directory: " + agentUpdateBackupDir, "");
						Directory.CreateDirectory(agentUpdateBackupDir);
						LogUtil.LogInfo("Copy agent service files to backup directory", "");
						foreach (string text in enumerable)
						{
							File.Copy(text, Path.Combine(agentUpdateBackupDir, Path.GetFileName(text)));
						}
						foreach (string text2 in enumerable2)
						{
							if (Path.GetFileName(text2).ToLower() != "ServiceInstaller.exe".ToLower())
							{
								File.Copy(text2, Path.Combine(agentUpdateBackupDir, Path.GetFileName(text2)));
							}
						}
					}
					catch (Exception)
					{
						throw new AgentInstallException("Failed backup installation files prior to update.");
					}
					try
					{
						LogUtil.LogInfo("Delete previous agent service executable: OrchestratorAgent.exe", "");
						if (File.Exists(Path.Combine(agentInstallDir, "OrchestratorAgent.exe")))
						{
							File.Delete(Path.Combine(agentInstallDir, "OrchestratorAgent.exe"));
						}
						LogUtil.LogInfo("Delete service agent files", "");
						foreach (string path in enumerable)
						{
							File.Delete(path);
						}
						foreach (string path2 in enumerable2)
						{
							File.Delete(path2);
						}
						goto IL_1D1;
					}
					catch (Exception)
					{
						throw new AgentInstallException("Failed to delete the currently installed agent files in preparation for update.");
					}
				}
				LogUtil.LogInfo("Agent service directory does not exist, creating a new one: " + agentInstallDir, "");
				Directory.CreateDirectory(agentInstallDir);
				IL_1D1:;
			}
			catch (AgentInstallException ex)
			{
				throw ex;
			}
			catch (Exception)
			{
				throw new AgentInstallException("An error occured while preparing agent directory.");
			}
		}

		private static void Install_ExtractToAgentDirectory(string agentInstallDir, int? clientId, bool writeConfig, string tenantName = "", bool activityNode = false)
		{
			try
			{
				using (MemoryStream memoryStream = new MemoryStream(Resources.OrchestratorAgentService))
				{
					new ZipArchive(memoryStream).ExtractToDirectory(agentInstallDir, true);
				}
				LogUtil.LogInfo("Copy installer file into the agent service directory.", "");
				File.Copy(Assembly.GetExecutingAssembly().Location, Path.Combine(agentInstallDir, "ServiceInstaller.exe"), true);
				if (writeConfig)
				{
					LogUtil.LogInfo("Write config.json file to installation directory.", "");
					string configString = AgentInstallerConfigUtil.GetConfigString(clientId, tenantName, activityNode);
					File.WriteAllText(Path.Combine(agentInstallDir, "config.json"), configString);
				}
			}
			catch (Exception ex)
			{
				AgentInstallController.DisplayMessage(true, ex.ToString(), ex.ToString());
				throw new AgentInstallException("Could not extract installation files to agent directory.");
			}
		}

		private static void Install_Rollback(string agentInstallDir, string agentUpdateBackupDir)
		{
			LogUtil.LogInfo("Begin rollback of unsuccessful installation.", "");
			try
			{
				LogUtil.LogInfo("Delete agent service files from installation directory.", "");
				IEnumerable<string> enumerable = Directory.EnumerateFiles(agentInstallDir, "*.dll", SearchOption.TopDirectoryOnly);
				IEnumerable<string> enumerable2 = Directory.EnumerateFiles(agentInstallDir, "*.exe", SearchOption.TopDirectoryOnly);
				File.Delete(Path.Combine(agentInstallDir, "OrchestratorAgent.exe"));
				foreach (string path in enumerable)
				{
					File.Delete(path);
				}
				foreach (string path2 in enumerable2)
				{
					if (Path.GetFileName(path2).ToLower() != "ServiceInstaller.exe".ToLower())
					{
						File.Delete(path2);
					}
				}
				LogUtil.LogInfo("Restore the previously backed up files to the installation directory.", "");
				foreach (string text in Directory.EnumerateFiles(agentUpdateBackupDir, "*.dll", SearchOption.TopDirectoryOnly))
				{
					File.Copy(text, Path.Combine(agentInstallDir, Path.GetFileName(text)));
				}
				File.Copy(Path.Combine(agentUpdateBackupDir, "OrchestratorAgent.exe"), Path.Combine(agentInstallDir, "OrchestratorAgent.exe"));
				enumerable2 = Directory.EnumerateFiles(agentUpdateBackupDir, "*.exe", SearchOption.TopDirectoryOnly);
				foreach (string text2 in enumerable2)
				{
					if (Path.GetFileName(text2).ToLower() != "ServiceInstaller.exe".ToLower())
					{
						File.Copy(text2, Path.Combine(agentInstallDir, Path.GetFileName(text2)));
					}
				}
			}
			catch (Exception)
			{
				throw new AgentInstallException("ROLLBACK_FAILED.");
			}
		}

		private static void Install_EnsureServiceInstalled(string agentInstallDir)
		{
			try
			{
				ServiceInstaller.Install("OrchestratorAgent", "OrchestratorAgent", "\"" + Path.Combine(agentInstallDir, "OrchestratorAgent.exe") + "\"");
			}
			catch (InvalidOperationException ex)
			{
				throw new AgentInstallException(ex.Message, true);
			}
			catch (Exception e)
			{
				throw new AgentInstallException("Failed to install windows service for the agent." + ExceptionLoggingUtil.GetExceptionInformation(e));
			}
		}

		private static void Install_StartService()
		{
			try
			{
				if (ServiceInstaller.GetServiceStatus("OrchestratorAgent") != ServiceState.Running)
				{
					ServiceInstaller.StartService("OrchestratorAgent");
				}
			}
			catch (Exception)
			{
				throw new AgentInstallException("Failed to start windows service for the agent.");
			}
		}

		public static void Update(bool isInteractive)
		{
			AgentInstallController.IsInteractiveMode = isInteractive;
			string text = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "OrchestratorAgent");
			string agentUpdateBackupDir = Path.Combine(text, "UpdateBackup");
			LogUtil.LogInfo("Ensure service is stopped prior to update.", "");
			AgentInstallController.Install_StopService();
			LogUtil.LogInfo("Prepare agent install directory.", "");
			AgentInstallController.Install_PrepareAgentDirectory(text, agentUpdateBackupDir);
			try
			{
				LogUtil.LogInfo("Extract agent executables to installation directory", "");
				AgentInstallController.Install_ExtractToAgentDirectory(text, null, false, "", false);
				AgentInstallController.FixVulnerablePathForExistingAgents();
				LogUtil.LogInfo("Start the agent service.", "");
				AgentInstallController.Install_StartService();
			}
			catch (Exception ex)
			{
				try
				{
					AgentInstallController.DisplayMessage(true, ex.ToString(), "Update");
					AgentInstallController.Install_Rollback(text, agentUpdateBackupDir);
					throw new Exception(ex.Message + " Update has been rolled back.");
				}
				catch (Exception ex2)
				{
					throw new Exception(ex.Message + " " + ex2.Message);
				}
			}
		}

		public static void Install(bool isInteractive, int? clientId, string tenantName = "", bool activityNode = false)
		{
			AgentInstallController.IsInteractiveMode = isInteractive;
			string text = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "OrchestratorAgent");
			string agentUpdateBackupDir = Path.Combine(text, "UpdateBackup");
			AgentInstallController.Uninstall(false, false);
			LogUtil.LogInfo("Prepare agent install directory.", "");
			AgentInstallController.Install_PrepareAgentDirectory(text, agentUpdateBackupDir);
			try
			{
				LogUtil.LogInfo("Extract agent executables to installation directory", "");
				AgentInstallController.Install_ExtractToAgentDirectory(text, clientId, true, tenantName, activityNode);
				LogUtil.LogInfo("Install the windows service.", "");
				AgentInstallController.Install_EnsureServiceInstalled(text);
				LogUtil.LogInfo("Start the agent service.", "");
				AgentInstallController.Install_StartService();
			}
			catch (Exception ex)
			{
				try
				{
					AgentInstallController.DisplayMessage(true, ex.ToString(), "Install");
					AgentInstallController.Install_Rollback(text, agentUpdateBackupDir);
					throw new Exception("Install has been rolled back.");
				}
				catch (Exception ex2)
				{
					throw new AgentInstallException(ex.Message + " " + ex2.Message);
				}
			}
		}

		private static void Install_Uninstall()
		{
			try
			{
				if (ServiceInstaller.GetServiceStatus("OrchestratorAgent") != ServiceState.NotFound)
				{
					ServiceInstaller.Uninstall("OrchestratorAgent");
				}
			}
			catch (Exception)
			{
				throw new AgentInstallException("Uninstall Failed. Could not remove Windows Service.");
			}
		}

		private static void Install_DeleteAgentFiles()
		{
			string text = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "OrchestratorAgent");
			try
			{
				if (Directory.Exists(text))
				{
					bool flag = false;
					int num = 0;
					if (File.Exists(Path.Combine(text, "LogFile_Installer.txt")))
					{
						string text2 = Path.Combine(Path.GetTempPath(), "OrchestratorUninstallLog_LogFile_Installer.txt");
						File.Copy(Path.Combine(text, "LogFile_Installer.txt"), text2, true);
						LogUtil.LogInfo("Copied log file to temp: " + text2, "");
					}
					if (File.Exists(Path.Combine(text, "LogFile.txt")))
					{
						string text3 = Path.Combine(Path.GetTempPath(), "OrchestratorUninstallLog_LogFile.txt");
						File.Copy(Path.Combine(text, "LogFile.txt"), text3, true);
						LogUtil.LogInfo("Copied log file to temp: " + text3, "");
					}
					while (!flag && num < 0xA)
					{
						try
						{
							Directory.Delete(text, true);
							flag = true;
						}
						catch (UnauthorizedAccessException)
						{
							LogUtil.LogInfo("Issue with deleting files (unauthorised) - typically this occurs if a file is open / being accessed - retry " + (num + 1).ToString() + " of 10.", "");
							num++;
							Thread.Sleep(0x3E8);
						}
					}
				}
			}
			catch (Exception)
			{
				throw new AgentInstallException("Partial uninstall: Windows Service removed but failed to remove agent install directory.");
			}
		}

		public static bool RemoveCertificate()
		{
			bool result;
			using (NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", "orchestratorservicenamedpipe", PipeDirection.InOut))
			{
				try
				{
					LogUtil.LogInfo("Connecting to agent service.", "");
					namedPipeClientStream.Connect(0x3E8);
					if (!namedPipeClientStream.IsConnected)
					{
						return false;
					}
					LogUtil.LogInfo("Sending uninstall command to agent service.", "");
					byte[] bytes = Encoding.ASCII.GetBytes("UNINSTALLAGENT   ");
					namedPipeClientStream.Write(bytes, 0, bytes.Length);
					LogUtil.LogInfo("Read uninstall response from agent service.", "");
					byte[] array = new byte[8];
					namedPipeClientStream.Read(array, 0, 8);
					string @string = Encoding.ASCII.GetString(array, 0, 7);
					if (!string.IsNullOrEmpty(@string) && @string != "success")
					{
						return false;
					}
					LogUtil.LogInfo("Agent Service certificate removal successful.", "");
				}
				catch (Exception)
				{
					return false;
				}
				result = true;
			}
			return result;
		}

		public static bool Uninstall(bool isInteractive = true, bool removeCertificate = false)
		{
			AgentInstallController.IsInteractiveMode = isInteractive;
			if (removeCertificate && !AgentInstallController.RemoveCertificate())
			{
				LogUtil.LogInfo("Could not verify certificate removal.", "");
				AgentInstallController.DisplayMessage(false, "Could not verify certificate removal.", "");
			}
			LogUtil.LogInfo("Stop agent service.", "");
			AgentInstallController.Install_StopService();
			LogUtil.LogInfo("Remove OrchestratorAgent windows service.", "");
			AgentInstallController.Install_Uninstall();
			LogUtil.LogInfo("Delete agent service files from installation directory.", "");
			AgentInstallController.Install_DeleteAgentFiles();
			return true;
		}

		private static void DisplayMessage(bool isError, string message, string title = "")
		{
			if (!isError)
			{
				LogUtil.LogInfo(message, "");
			}
			if (AgentInstallController.IsInteractiveMode)
			{
				if (string.IsNullOrEmpty(title))
				{
					MessageBox.Show(message, "OrchestratorAgent");
					return;
				}
				MessageBox.Show(message, title);
			}
		}

		private static void FixVulnerablePathForExistingAgents()
		{
			try
			{
				using (ManagementObject managementObject = new ManagementObject("Win32_Service.Name='OrchestratorAgent'"))
				{
					string text = managementObject["PathName"].ToString();
					if (string.IsNullOrEmpty(text))
					{
						AgentInstallController.DisplayMessage(true, "Empty Image path of the service was empty.Try running the installer as an Administrator.", "Empty Image path.");
					}
					else
					{
						if (AgentInstallController.IsPathVulnerable(text))
						{
							string text2 = "\"" + text.Trim(new char[]
							{
								'"'
							}) + "\"";
							using (ManagementBaseObject methodParameters = managementObject.GetMethodParameters("Change"))
							{
								methodParameters["PathName"] = text2;
								uint num = (uint)managementObject.InvokeMethod("Change", methodParameters, null)["ReturnValue"];
								if (num == 0U)
								{
									AgentInstallController.DisplayMessage(false, "Imagepath has been updated for OrchestratorAgent. old path: " + text + " new path; " + text2, "");
								}
								else
								{
									AgentInstallController.DisplayMessage(true, string.Format("Imagepath was not updated. Result code {0}. Old path: {1} new path; {2}", num, text, text2), "");
								}
								goto IL_102;
							}
						}
						AgentInstallController.DisplayMessage(false, "Existing imagePath is valid. " + text + ".", "");
						IL_102:;
					}
				}
			}
			catch (Exception e)
			{
				AgentInstallController.DisplayMessage(true, "Failed updating imagePath. " + ExceptionLoggingUtil.GetExceptionInformation(e), "");
			}
		}

		private static bool IsPathVulnerable(string path)
		{
			return (path.StartsWith("\"") && !path.EndsWith("\"")) || (!path.StartsWith("\"") && path.EndsWith("\"")) || (!path.StartsWith("\"") && !path.EndsWith("\""));
		}

		public AgentInstallController()
		{
		}

		static AgentInstallController()
		{
		}

		private static bool IsInteractiveMode = true;

		public const string AgentInstallFolder = "OrchestratorAgent";

		public const string InstallerLogName = "LogFile_Installer.txt";

		public const string LogName = "LogFile.txt";

		public const string AgentExecuteableName = "OrchestratorAgent.exe";

		public const string ServiceName = "OrchestratorAgent";

		public const string UpdateBackupDir = "UpdateBackup";

		public const string NamedPipeServer = "orchestratorservicenamedpipe";

		public const string InstallerName = "ServiceInstaller.exe";
	}
}
```

**AgentInstallerConfigUtil.cs**

```cs
using System;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace ServiceInstaller
{
	public class AgentInstallerConfigUtil
	{
		public static string GetConfigString(int? clientId, string tenantName = "", bool activityNode = false)
		{
			AgentServiceInstallerEmbeddedConfig config = AgentInstallerConfigUtil.GetConfig();
			string text;
			if (clientId != null)
			{
				int? num = clientId;
				int num2 = 0;
				if (num.GetValueOrDefault() >= num2 & num != null)
				{
					text = clientId.ToString();
					goto IL_3D;
				}
			}
			text = "0";
			IL_3D:
			string str = text;
			string str2 = Regex.Replace(((config != null) ? config.TenantDomain : null) ?? tenantName, "[^0-9\\.A-Za-z-:]", "");
			return "" + "{" + "    \"ClientId\":  " + str + "," + (activityNode ? "   \"IsActivityNode\": true," : "") + "    \"TenantDomain\": \"" + str2 + "\"" + "}";
		}

		private static AgentServiceInstallerEmbeddedConfig GetConfig()
		{
			AgentServiceInstallerEmbeddedConfig result;
			using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("AGENT_CONFIG_EMBED"))
			{
				if (manifestResourceStream == null)
				{
					result = null;
				}
				else
				{
					result = (AgentServiceInstallerEmbeddedConfig)new XmlSerializer(typeof(AgentServiceInstallerEmbeddedConfig)).Deserialize(manifestResourceStream);
				}
			}
			return result;
		}

		public AgentInstallerConfigUtil()
		{
		}

		private const string EMBED_RESOURCE_NAME = "AGENT_CONFIG_EMBED";
	}
}
```

**AgentInstallException.cs**

```cs
using System;

namespace ServiceInstaller
{
	public class AgentInstallException : Exception
	{
		public bool DisplayNotification { get; set; }

		public AgentInstallException(string message, bool displayNotification) : base(message)
		{
			this.DisplayNotification = displayNotification;
		}

		public AgentInstallException(string message) : base(message)
		{
		}
	}
}
```

**AgentServiceInstallerEmbeddedConfig.cs**

```cs
using System;

namespace ServiceInstaller
{
	public class AgentServiceInstallerEmbeddedConfig
	{
		public string TenantDomain { get; set; }

		public AgentServiceInstallerEmbeddedConfig()
		{
		}
	}
}
```

**ExceptionLoggingUtil.cs**

```cs
using System;
using System.IO;
using System.Net;

namespace ServiceInstaller
{
	public static class ExceptionLoggingUtil
	{
		public static string GetExceptionInformation(Exception e)
		{
			try
			{
				if (e == null)
				{
					return "";
				}
				string text = "";
				if (e.Message != null)
				{
					text = text + "Exception Occured. Message: " + e.Message + "\r\n";
				}
				if (e is WebException)
				{
					try
					{
						using (Stream responseStream = ((WebException)e).Response.GetResponseStream())
						{
							using (StreamReader streamReader = new StreamReader(responseStream))
							{
								text = text + "Web Error Response: " + streamReader.ReadToEnd();
							}
						}
					}
					catch (Exception)
					{
					}
				}
				if (e.StackTrace != null)
				{
					text = text + "Stack Trace: " + e.StackTrace + "\r\n";
				}
				if (e.InnerException != null)
				{
					if (e.InnerException.Message != null)
					{
						text = text + "Inner Exception Message: " + e.InnerException.StackTrace + "\r\n";
					}
					if (e.InnerException is WebException)
					{
						try
						{
							using (Stream responseStream2 = ((WebException)e.InnerException).Response.GetResponseStream())
							{
								using (StreamReader streamReader2 = new StreamReader(responseStream2))
								{
									text = text + "Inner Exception Web Error: " + streamReader2.ReadToEnd();
								}
							}
						}
						catch (Exception)
						{
						}
					}
					if (e.InnerException.StackTrace != null)
					{
						text = text + "Inner Exception Stack Trace: " + e.InnerException.StackTrace;
					}
				}
				return text;
			}
			catch (Exception)
			{
			}
			return "Error could not be determined.";
		}
	}
}
```

**Installer.cs**

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using ServiceInstaller.Helpers;
using ServiceInstaller.Properties;

namespace ServiceInstaller
{
	public class Installer : Form
	{
		public Installer()
		{
			this.InitializeComponent();
			Icon icon = Icon.FromHandle(Resources.favicon.GetHicon());
			base.Icon = icon;
			icon.Dispose();
		}

		private void UpdateButtonStates()
		{
			if (AgentInstallController.CheckIfInstalled())
			{
				this.installButton.Enabled = false;
				this.uninstallButton.Enabled = true;
				return;
			}
			this.installButton.Enabled = true;
			this.uninstallButton.Enabled = false;
		}

		private void DisableButton(bool disableUninstall)
		{
			if (disableUninstall)
			{
				this.uninstallButton.Enabled = false;
				return;
			}
			this.installButton.Enabled = false;
		}

		private void Installer_Load(object sender, EventArgs e)
		{
			this.UpdateButtonStates();
		}

		private void installButton_Click(object sender, EventArgs e)
		{
			try
			{
				LogUtil.LogInfo("Execute install for agent service", "");
				string tenantName = PE32Binary.GetTenantName();
				AgentInstallController.Install(true, null, tenantName, false);
				MessageBox.Show("Installation Complete!");
			}
			catch (AgentInstallException ex)
			{
				MessageBox.Show(ex.Message);
			}
			catch (Exception ex2)
			{
				MessageBox.Show(ex2.ToString(), "Unknown error occured during installation.");
			}
			finally
			{
				this.UpdateButtonStates();
			}
		}

		private void uninstallButton_Click(object sender, EventArgs e)
		{
			try
			{
				LogUtil.LogInfo("Execute uninstall for agent service", "");
				this.DisableButton(true);
				if (AgentInstallController.Uninstall(true, true))
				{
					MessageBox.Show("Uninstall Complete!");
				}
				else
				{
					MessageBox.Show("Uninstall did not Complete!");
				}
			}
			catch (AgentInstallException ex)
			{
				MessageBox.Show(ex.Message);
			}
			catch (Exception ex2)
			{
				MessageBox.Show(ex2.ToString(), "Unknown error occured during uninstall.");
			}
			finally
			{
				this.UpdateButtonStates();
			}
		}

		protected override void Dispose(bool disposing)
		{
			if (disposing && this.components != null)
			{
				this.components.Dispose();
			}
			base.Dispose(disposing);
		}

		private void InitializeComponent()
		{
			this.installButton = new Button();
			this.uninstallButton = new Button();
			base.SuspendLayout();
			this.installButton.Font = new Font("Microsoft Sans Serif", 14f, FontStyle.Regular, GraphicsUnit.Point, 0);
			this.installButton.Location = new Point(0x12, 0xF);
			this.installButton.Name = "installButton";
			this.installButton.Size = new Size(0xA9, 0x41);
			this.installButton.TabIndex = 0;
			this.installButton.Text = "Install";
			this.installButton.UseVisualStyleBackColor = true;
			this.installButton.Click += this.installButton_Click;
			this.uninstallButton.Font = new Font("Microsoft Sans Serif", 14f, FontStyle.Regular, GraphicsUnit.Point, 0);
			this.uninstallButton.Location = new Point(0x12, 0x5A);
			this.uninstallButton.Name = "uninstallButton";
			this.uninstallButton.Size = new Size(0xA9, 0x41);
			this.uninstallButton.TabIndex = 1;
			this.uninstallButton.Text = "Uninstall";
			this.uninstallButton.UseVisualStyleBackColor = true;
			this.uninstallButton.Click += this.uninstallButton_Click;
			base.AutoScaleDimensions = new SizeF(6f, 13f);
			base.AutoScaleMode = AutoScaleMode.Font;
			base.ClientSize = new Size(0xCA, 0xA8);
			base.Controls.Add(this.uninstallButton);
			base.Controls.Add(this.installButton);
			base.MaximizeBox = false;
			this.MaximumSize = new Size(0xDA, 0xCF);
			this.MinimumSize = new Size(0xDA, 0xCF);
			base.Name = "Installer";
			this.Text = "Agent";
			base.Load += this.Installer_Load;
			base.ResumeLayout(false);
		}

		private IContainer components;

		private Button installButton;

		private Button uninstallButton;
	}
}

```

**Installer.Designer.cs**

```cs
namespace ServiceInstaller
{
	public partial class Installer : System.Windows.Forms.Form
	{
		protected override void Dispose(bool disposing)
		{
			if (disposing && this.components != null)
			{
				this.components.Dispose();
			}
			base.Dispose(disposing);
		}

		private void InitializeComponent()
		{
			this.installButton = new System.Windows.Forms.Button();
			this.uninstallButton = new System.Windows.Forms.Button();
			base.SuspendLayout();
			this.installButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 14f, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
			this.installButton.Location = new System.Drawing.Point(0x12, 0xF);
			this.installButton.Name = "installButton";
			this.installButton.Size = new System.Drawing.Size(0xA9, 0x41);
			this.installButton.TabIndex = 0;
			this.installButton.Text = "Install";
			this.installButton.UseVisualStyleBackColor = true;
			this.installButton.Click += new System.EventHandler(this.installButton_Click);
			this.uninstallButton.Font = new System.Drawing.Font("Microsoft Sans Serif", 14f, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
			this.uninstallButton.Location = new System.Drawing.Point(0x12, 0x5A);
			this.uninstallButton.Name = "uninstallButton";
			this.uninstallButton.Size = new System.Drawing.Size(0xA9, 0x41);
			this.uninstallButton.TabIndex = 1;
			this.uninstallButton.Text = "Uninstall";
			this.uninstallButton.UseVisualStyleBackColor = true;
			this.uninstallButton.Click += new System.EventHandler(this.uninstallButton_Click);
			base.AutoScaleDimensions = new System.Drawing.SizeF(6f, 13f);
			base.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			base.ClientSize = new System.Drawing.Size(0xCA, 0xA8);
			base.Controls.Add(this.uninstallButton);
			base.Controls.Add(this.installButton);
			base.MaximizeBox = false;
			this.MaximumSize = new System.Drawing.Size(0xDA, 0xCF);
			this.MinimumSize = new System.Drawing.Size(0xDA, 0xCF);
			base.Name = "Installer";
			this.Text = "Agent";
			base.Load += new System.EventHandler(this.Installer_Load);
			base.ResumeLayout(false);
		}

		private System.ComponentModel.IContainer components;

		private System.Windows.Forms.Button installButton;

		private System.Windows.Forms.Button uninstallButton;
	}
}
```

**LogUtil.cs**

```cs
using System;
using System.Collections.Generic;
using System.IO;

namespace ServiceInstaller
{
	public static class LogUtil
	{
		public static void LogInfo(string shortMessage, string detailDescription = "")
		{
			LogUtil.Log("Informational", shortMessage, detailDescription);
		}

		public static void LogError(string shortMessage, string detailDescription = "")
		{
			LogUtil.Log("Error", shortMessage, detailDescription);
		}

		public static void LogWarning(string shortMessage, string detailDescription = "")
		{
			LogUtil.Log("Warning", shortMessage, detailDescription);
		}

		private static void Log(string type, string shortDescription, string detailDescription = "")
		{
			string str = DateTime.Now.ToString("ddd MMM  d H:mm:ss yyyy:") + "\t" + type + "\t";
			if (type == "Error")
			{
				str += "\t";
			}
			string text = str + shortDescription;
			if (detailDescription != "")
			{
				text += " For more information please see log file";
			}
			Console.WriteLine(text);
			if (detailDescription != "")
			{
				text = str + detailDescription;
				if (type != "Error")
				{
					text = str + shortDescription + "\r\n";
					text = text + "Detail description: " + detailDescription + "\r\n";
				}
			}
			LogUtil.logLines.Add(text);
			string agentInstallationDirectory = LogUtil.GetAgentInstallationDirectory();
			try
			{
				if (Directory.Exists(agentInstallationDirectory))
				{
					File.AppendAllLines(Path.Combine(agentInstallationDirectory, "LogFile_Installer.txt"), LogUtil.logLines);
					LogUtil.logLines.Clear();
				}
			}
			catch (DirectoryNotFoundException)
			{
			}
			catch (UnauthorizedAccessException)
			{
			}
		}

		private static string GetAgentInstallationDirectory()
		{
			string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
			string path = Path.Combine(folderPath, "OrchestratorAgent");
			return Path.Combine(folderPath, path);
		}

		static LogUtil()
		{
		}

		private static List<string> logLines = new List<string>();
	}
}

```

**Program.cs**

```cs
using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using ServiceInstaller.Helpers;

namespace ServiceInstaller
{
	internal static class Program
	{
		[DllImport("kernel32.dll")]
		private static extern bool AttachConsole(int processId);

		[STAThread]
		private static void Main(string[] args)
		{
			if (args.Length != 0)
			{
				string[] source = new string[]
				{
					"-install",
					"-uninstall",
					"-clientid",
					"-clearcertificate",
					"-update",
					"-tenantname",
					"-activitynode"
				};
				Program.AttachConsole(-1);
				try
				{
					string text = "";
					int? num = null;
					bool flag = true;
					string text2 = "";
					bool activityNode = false;
					LogUtil.LogInfo("Log file name: LogFile_Installer.txt", "");
					string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
					string path = Path.Combine(folderPath, "OrchestratorAgent");
					string str = Path.Combine(folderPath, path);
					LogUtil.LogInfo("Location: " + str, "");
					int i = 0;
					while (i < args.Length)
					{
						if (!source.Contains(args[i].ToLower()))
						{
							throw new Exception("Unknown command \"" + args[i] + "\" found.");
						}
						if (string.Compare(args[i].ToLower(), "-clientid") == 0)
						{
							try
							{
								i++;
								num = new int?(int.Parse(args[i]));
								goto IL_1DF;
							}
							catch (Exception ex)
							{
								LogUtil.LogError(ex.Message, "Error encountered while parsing client id.\r\n" + ExceptionLoggingUtil.GetExceptionInformation(ex));
								goto IL_1DF;
							}
							goto IL_12E;
						}
						goto IL_12E;
						IL_1DF:
						i++;
						continue;
						IL_12E:
						if (string.Compare(args[i].ToLower(), "-clearcertificate") == 0)
						{
							try
							{
								i++;
								flag = bool.Parse(args[i]);
								goto IL_1DF;
							}
							catch (Exception)
							{
								i--;
								flag = true;
								LogUtil.LogInfo("Value for \"clearcertificate\" was not found. Setting it to true.", "");
								goto IL_1DF;
							}
						}
						if (string.Compare(args[i].ToLower(), "-tenantname") == 0)
						{
							try
							{
								i++;
								text2 = args[i];
								goto IL_1DF;
							}
							catch (Exception)
							{
								i--;
								LogUtil.LogInfo("Value for \"tenantName\" was not found. Setting it to true.", "");
								goto IL_1DF;
							}
						}
						if (string.Compare(args[i].ToLower(), "-activitynode") == 0)
						{
							activityNode = true;
							goto IL_1DF;
						}
						if (!string.IsNullOrEmpty(text))
						{
							throw new Exception("Multiple actions found. Only one action [-install/-uninstall] should be provided.");
						}
						text = args[i];
						goto IL_1DF;
					}
					if (string.Compare(text, "-uninstall", true) == 0)
					{
						LogUtil.LogInfo("Execute silent uninstall for agent service", "");
						AgentInstallController.Uninstall(false, flag);
					}
					else if (string.Compare(text, "-install", true) == 0)
					{
						LogUtil.LogInfo("Execute silent install for agent service", "");
						text2 = (string.IsNullOrEmpty(text2) ? PE32Binary.GetTenantName() : text2);
						AgentInstallController.Install(false, num, text2, activityNode);
					}
					else if (string.Compare(text, "-update", true) == 0)
					{
						LogUtil.LogInfo("Execute silent update for agent service", "");
						AgentInstallController.Update(false);
					}
					LogUtil.LogInfo(string.Format("Client id: {0} clearcert: {1} action: {2}", num, flag, text), "");
					return;
				}
				catch (Exception ex2)
				{
					LogUtil.LogError(ex2.Message, ExceptionLoggingUtil.GetExceptionInformation(ex2));
					return;
				}
			}
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Installer());
		}
	}
}
```

**RecoveryOptionsElement.cs**

```cs
using System;
using System.Configuration;

namespace ServiceInstaller
{
	public class RecoveryOptionsElement : ConfigurationElement
	{
		public RecoveryOptionsElement()
		{
			this.FirstFailureAction = ServiceRecoveryAction.TakeNoAction;
			this.SecondFailureAction = ServiceRecoveryAction.TakeNoAction;
			this.SubsequentFailureActions = ServiceRecoveryAction.TakeNoAction;
			this.DaysToResetFailAcount = 0;
			this.MinutesToRestartService = 1;
		}

		[ConfigurationProperty("firstFailureAction")]
		public ServiceRecoveryAction FirstFailureAction
		{
			get
			{
				return (ServiceRecoveryAction)base["firstFailureAction"];
			}
			set
			{
				base["firstFailureAction"] = value;
			}
		}

		[ConfigurationProperty("secondFailureAction")]
		public ServiceRecoveryAction SecondFailureAction
		{
			get
			{
				return (ServiceRecoveryAction)base["secondFailureAction"];
			}
			set
			{
				base["secondFailureAction"] = value;
			}
		}

		[ConfigurationProperty("subsequentFailureAction")]
		public ServiceRecoveryAction SubsequentFailureActions
		{
			get
			{
				return (ServiceRecoveryAction)base["subsequentFailureAction"];
			}
			set
			{
				base["subsequentFailureAction"] = value;
			}
		}

		[ConfigurationProperty("daysToResetFailAcount")]
		public int DaysToResetFailAcount
		{
			get
			{
				return (int)base["daysToResetFailAcount"];
			}
			set
			{
				base["daysToResetFailAcount"] = value;
			}
		}

		[ConfigurationProperty("minutesToRestartService")]
		public int MinutesToRestartService
		{
			get
			{
				return (int)base["minutesToRestartService"];
			}
			set
			{
				base["minutesToRestartService"] = value;
			}
		}

		[ConfigurationProperty("rebootMessage")]
		public string RebootMessage
		{
			get
			{
				return (string)base["rebootMessage"];
			}
			set
			{
				base["rebootMessage"] = value;
			}
		}

		[ConfigurationProperty("commandToLaunchOnFailure")]
		public string CommandToLaunchOnFailure
		{
			get
			{
				return (string)base["commandToLaunchOnFailure"];
			}
			set
			{
				base["commandToLaunchOnFailure"] = value;
			}
		}
	}
}

```

**ScmAccessRights.cs**

```cs
using System;

namespace ServiceInstaller
{
	[Flags]
	public enum ScmAccessRights
	{
		Connect = 1,
		CreateService = 2,
		EnumerateService = 4,
		Lock = 8,
		QueryLockStatus = 0x10,
		ModifyBootConfig = 0x20,
		StandardRightsRequired = 0xF0000,
		AllAccess = 0xF003F
	}
}


```

**ServiceAccessRights.cs**

```cs
using System;

namespace ServiceInstaller
{
	[Flags]
	public enum ServiceAccessRights
	{
		QueryConfig = 1,
		ChangeConfig = 2,
		QueryStatus = 4,
		EnumerateDependants = 8,
		Start = 0x10,
		Stop = 0x20,
		PauseContinue = 0x40,
		Interrogate = 0x80,
		UserDefinedControl = 0x100,
		Delete = 0x10000,
		StandardRightsRequired = 0xF0000,
		AllAccess = 0xF01FF
	}
}

```

**ServiceBootFlag.cs**

```cs
using System;

namespace ServiceInstaller
{
	public enum ServiceBootFlag
	{
		Start,
		SystemStart,
		AutoStart,
		DemandStart,
		Disabled
	}
}

```

**ServiceControl.cs**

```cs
using System;

namespace ServiceInstaller
{
	public enum ServiceControl
	{
		Stop = 1,
		Pause,
		Continue,
		Interrogate,
		Shutdown,
		ParamChange,
		NetBindAdd,
		NetBindRemove,
		NetBindEnable,
		NetBindDisable
	}
}


```

**ServiceError.cs**

```cs
using System;

namespace ServiceInstaller
{
	public enum ServiceError
	{
		Ignore,
		Normal,
		Severe,
		Critical
	}
}


```

**ServiceInstaller.cs**

```cs
using System;
using System.Runtime.InteropServices;
using System.ServiceProcess;
using System.Threading;

namespace ServiceInstaller
{
	public static class ServiceInstaller
	{
		public static string GetAllowedUserAccountUserName { get; set; }

		public static string GetAllowedUserAccountPassword { get; set; }

		public static string GetAllowedDomainUserAccount { get; set; }

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, EntryPoint = "OpenSCManagerW", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr OpenSCManager(string machineName, string databaseName, ScmAccessRights dwDesiredAccess);

		[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, ServiceAccessRights dwDesiredAccess);

		[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr CreateService(IntPtr hSCManager, string lpServiceName, string lpDisplayName, ServiceAccessRights dwDesiredAccess, int dwServiceType, ServiceBootFlag dwStartType, ServiceError dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, IntPtr lpdwTagId, string lpDependencies, string lp, string lpPassword);

		[DllImport("advapi32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool CloseServiceHandle(IntPtr hSCObject);

		[DllImport("advapi32.dll")]
		private static extern int QueryServiceStatus(IntPtr hService, ServiceInstaller.SERVICE_STATUS lpServiceStatus);

		[DllImport("advapi32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool DeleteService(IntPtr hService);

		[DllImport("advapi32.dll")]
		private static extern int ControlService(IntPtr hService, ServiceControl dwControl, ServiceInstaller.SERVICE_STATUS lpServiceStatus);

		[DllImport("advapi32.dll", SetLastError = true)]
		private static extern int StartService(IntPtr hService, int dwNumServiceArgs, int lpServiceArgVectors);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool ChangeServiceConfig2(IntPtr hService, int dwInfoLevel, IntPtr lpInfo);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		private static extern int QueryServiceConfig2(IntPtr hService, int dwInfoLevel, IntPtr lpBuffer, uint cbBufSize, out uint pcbBytesNeeded);

		public static void Uninstall(string serviceName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.AllAccess);
			try
			{
				IntPtr intPtr2 = ServiceInstaller.OpenService(intPtr, serviceName, ServiceAccessRights.AllAccess);
				if (intPtr2 == IntPtr.Zero)
				{
					throw new ApplicationException("Service not installed.");
				}
				try
				{
					ServiceInstaller.StopService(intPtr2);
					if (!ServiceInstaller.DeleteService(intPtr2))
					{
						int lastWin32Error = Marshal.GetLastWin32Error();
						if (lastWin32Error != 0x430)
						{
							throw new ApplicationException("Could not delete service " + lastWin32Error.ToString());
						}
					}
				}
				finally
				{
					ServiceInstaller.CloseServiceHandle(intPtr2);
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
		}

		public static bool ServiceIsInstalled(string serviceName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.Connect);
			bool result;
			try
			{
				IntPtr intPtr2 = ServiceInstaller.OpenService(intPtr, serviceName, ServiceAccessRights.QueryStatus);
				if (intPtr2 == IntPtr.Zero)
				{
					result = false;
				}
				else
				{
					ServiceInstaller.CloseServiceHandle(intPtr2);
					result = true;
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
			return result;
		}

		public static void Install(string serviceName, string displayName, string fileName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.AllAccess);
			try
			{
				IntPtr intPtr2 = IntPtr.Zero;
				try
				{
					intPtr2 = ServiceInstaller.CreateService(intPtr, serviceName, displayName, ServiceAccessRights.AllAccess, 0x10, ServiceBootFlag.AutoStart, ServiceError.Normal, fileName, null, IntPtr.Zero, null, null, null);
					if (intPtr2 == IntPtr.Zero)
					{
						int lastWin32Error = Marshal.GetLastWin32Error();
						if (lastWin32Error == 0x430)
						{
							throw new InvalidOperationException("The service cannot be installed as it is in an uninstalling state after being recently uninstalled. Please wait and retry again in a few minutes. If the issue persists, restart the machine before attempting again.");
						}
						throw new ApplicationException("Failed to install service with error: " + lastWin32Error.ToString());
					}
				}
				finally
				{
					if (intPtr2 != IntPtr.Zero)
					{
						ServiceInstaller.CloseServiceHandle(intPtr2);
					}
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
		}

		public static void StartService(string serviceName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.Connect);
			try
			{
				IntPtr intPtr2 = ServiceInstaller.OpenService(intPtr, serviceName, ServiceAccessRights.QueryStatus | ServiceAccessRights.Start);
				if (intPtr2 == IntPtr.Zero)
				{
					throw new ApplicationException("Could not open service.");
				}
				try
				{
					ServiceInstaller.SetServiceRecoveryOptions(serviceName);
				}
				catch (Exception)
				{
				}
				try
				{
					ServiceInstaller.StartService(intPtr2);
				}
				finally
				{
					ServiceInstaller.CloseServiceHandle(intPtr2);
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
		}

		public static void StopService(string serviceName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.Connect);
			try
			{
				IntPtr intPtr2 = ServiceInstaller.OpenService(intPtr, serviceName, ServiceAccessRights.QueryStatus | ServiceAccessRights.Stop);
				if (intPtr2 == IntPtr.Zero)
				{
					throw new ApplicationException("Could not open service.");
				}
				try
				{
					ServiceInstaller.StopService(intPtr2);
				}
				finally
				{
					ServiceInstaller.CloseServiceHandle(intPtr2);
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
		}

		private static void StartService(IntPtr service)
		{
			new ServiceInstaller.SERVICE_STATUS();
			ServiceInstaller.StartService(service, 0, 0);
			if (!ServiceInstaller.WaitForServiceStatus(service, ServiceState.StartPending, ServiceState.Running))
			{
				throw new ApplicationException("Unable to start service");
			}
		}

		private static void StopService(IntPtr service)
		{
			ServiceInstaller.SERVICE_STATUS lpServiceStatus = new ServiceInstaller.SERVICE_STATUS();
			ServiceInstaller.ControlService(service, ServiceControl.Stop, lpServiceStatus);
			if (!ServiceInstaller.WaitForServiceStatus(service, ServiceState.StopPending, ServiceState.Stopped))
			{
				throw new ApplicationException("Unable to stop service");
			}
		}

		public static ServiceState GetServiceStatus(string serviceName)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(ScmAccessRights.Connect);
			ServiceState result;
			try
			{
				IntPtr intPtr2 = ServiceInstaller.OpenService(intPtr, serviceName, ServiceAccessRights.QueryStatus);
				if (intPtr2 == IntPtr.Zero)
				{
					result = ServiceState.NotFound;
				}
				else
				{
					try
					{
						result = ServiceInstaller.GetServiceStatus(intPtr2);
					}
					finally
					{
						ServiceInstaller.CloseServiceHandle(intPtr2);
					}
				}
			}
			finally
			{
				ServiceInstaller.CloseServiceHandle(intPtr);
			}
			return result;
		}

		private static ServiceState GetServiceStatus(IntPtr service)
		{
			ServiceInstaller.SERVICE_STATUS service_STATUS = new ServiceInstaller.SERVICE_STATUS();
			if (ServiceInstaller.QueryServiceStatus(service, service_STATUS) == 0)
			{
				throw new ApplicationException("Failed to query service status.");
			}
			return service_STATUS.dwCurrentState;
		}

		private static bool WaitForServiceStatus(IntPtr service, ServiceState waitStatus, ServiceState desiredStatus)
		{
			ServiceInstaller.SERVICE_STATUS service_STATUS = new ServiceInstaller.SERVICE_STATUS();
			ServiceInstaller.QueryServiceStatus(service, service_STATUS);
			if (service_STATUS.dwCurrentState == desiredStatus)
			{
				return true;
			}
			int tickCount = Environment.TickCount;
			int dwCheckPoint = service_STATUS.dwCheckPoint;
			for (int i = 0; i < 0xF; i++)
			{
				Thread.Sleep(0x3E8);
				ServiceInstaller.QueryServiceStatus(service, service_STATUS);
				if (service_STATUS.dwCurrentState == desiredStatus)
				{
					break;
				}
			}
			return service_STATUS.dwCurrentState == desiredStatus;
		}

		private static IntPtr OpenSCManager(ScmAccessRights rights)
		{
			IntPtr intPtr = ServiceInstaller.OpenSCManager(null, null, rights);
			if (intPtr == IntPtr.Zero)
			{
				throw new ApplicationException("Could not connect to service control manager.");
			}
			return intPtr;
		}

		public static void SetServiceRecoveryOptions(string serviceName)
		{
			ServiceRecoveryOptions serviceRecoveryOptions = ServiceInstaller.GetServiceRecoveryOptions(serviceName);
			if (serviceRecoveryOptions.FirstFailureAction != ServiceRecoveryAction.RestartTheComputer && serviceRecoveryOptions.SecondFailureAction != ServiceRecoveryAction.RestartTheComputer)
			{
				bool flag = serviceRecoveryOptions.SubsequentFailureActions == ServiceRecoveryAction.RestartTheComputer;
			}
			uint restartServiceAfter = (uint)TimeSpan.FromMinutes((double)serviceRecoveryOptions.MinutesToRestartService).TotalMilliseconds;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			ServiceController serviceController = null;
			try
			{
				serviceController = new ServiceController(serviceName);
				ServiceInstaller.SERVICE_FAILURE_ACTIONS structure = new ServiceInstaller.SERVICE_FAILURE_ACTIONS
				{
					dwResetPeriod = (int)TimeSpan.FromDays((double)serviceRecoveryOptions.DaysToResetFailAcount).TotalSeconds,
					cActions = 3,
					lpRebootMsg = serviceRecoveryOptions.RebootMessage
				};
				intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ServiceInstaller.SC_ACTION)) * 3);
				ServiceRecoveryAction[] array = new ServiceRecoveryAction[]
				{
					serviceRecoveryOptions.FirstFailureAction,
					serviceRecoveryOptions.SecondFailureAction,
					serviceRecoveryOptions.SubsequentFailureActions
				};
				for (int i = 0; i < array.Length; i++)
				{
					Marshal.StructureToPtr<ServiceInstaller.SC_ACTION>(ServiceInstaller.GetScAction(array[i], restartServiceAfter), (IntPtr)((long)intPtr2 + (long)(Marshal.SizeOf(typeof(ServiceInstaller.SC_ACTION)) * i)), false);
				}
				structure.lpsaActions = intPtr2;
				string commandToLaunchOnFailure = serviceRecoveryOptions.CommandToLaunchOnFailure;
				if (commandToLaunchOnFailure != null)
				{
					structure.lpCommand = commandToLaunchOnFailure;
				}
				intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ServiceInstaller.SERVICE_FAILURE_ACTIONS)));
				Marshal.StructureToPtr<ServiceInstaller.SERVICE_FAILURE_ACTIONS>(structure, intPtr, false);
				if (!ServiceInstaller.ChangeServiceConfig2(serviceController.ServiceHandle.DangerousGetHandle(), 2, intPtr))
				{
					throw new Exception(Marshal.GetLastWin32Error().ToString() + "Unable to change the Service configuration.");
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
				if (serviceController != null)
				{
					serviceController.Close();
				}
			}
		}

		public static ServiceRecoveryOptions GetServiceRecoveryOptions(string serviceName)
		{
			IntPtr intPtr = IntPtr.Zero;
			ServiceController serviceController = null;
			ServiceRecoveryOptions serviceRecoveryOptions;
			try
			{
				serviceController = new ServiceController(serviceName);
				intPtr = Marshal.AllocHGlobal(0x2000);
				uint num;
				if (ServiceInstaller.QueryServiceConfig2(serviceController.ServiceHandle.DangerousGetHandle(), 2, intPtr, 0x2000U, out num) == 0)
				{
					throw new Exception(Marshal.GetLastWin32Error().ToString() + "Unable to query the Service configuration.");
				}
				ServiceInstaller.SERVICE_FAILURE_ACTIONS service_FAILURE_ACTIONS = (ServiceInstaller.SERVICE_FAILURE_ACTIONS)Marshal.PtrToStructure(intPtr, typeof(ServiceInstaller.SERVICE_FAILURE_ACTIONS));
				serviceRecoveryOptions = new ServiceRecoveryOptions
				{
					DaysToResetFailAcount = (int)TimeSpan.FromSeconds((double)service_FAILURE_ACTIONS.dwResetPeriod).TotalDays,
					RebootMessage = service_FAILURE_ACTIONS.lpRebootMsg,
					CommandToLaunchOnFailure = service_FAILURE_ACTIONS.lpCommand
				};
				int num2 = 3;
				if (num2 != 0)
				{
					uint num3 = 0xEA60U;
					ServiceInstaller.SC_ACTION[] array = new ServiceInstaller.SC_ACTION[num2];
					for (int i = 0; i < service_FAILURE_ACTIONS.cActions; i++)
					{
						ServiceInstaller.SC_ACTION sc_ACTION = (ServiceInstaller.SC_ACTION)Marshal.PtrToStructure((IntPtr)(service_FAILURE_ACTIONS.lpsaActions.ToInt32() + Marshal.SizeOf(typeof(ServiceInstaller.SC_ACTION)) * i), typeof(ServiceInstaller.SC_ACTION));
						array[i] = sc_ACTION;
					}
					serviceRecoveryOptions.FirstFailureAction = ServiceInstaller.GetServiceRecoveryAction(null);
					serviceRecoveryOptions.SecondFailureAction = ServiceInstaller.GetServiceRecoveryAction(null);
					serviceRecoveryOptions.SubsequentFailureActions = ServiceInstaller.GetServiceRecoveryAction(null);
					serviceRecoveryOptions.MinutesToRestartService = (int)TimeSpan.FromMilliseconds(num3).TotalMinutes;
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (serviceController != null)
				{
					serviceController.Close();
				}
			}
			return serviceRecoveryOptions;
		}

		private static ServiceInstaller.SC_ACTION GetScAction(ServiceRecoveryAction action, uint restartServiceAfter)
		{
			ServiceInstaller.SC_ACTION result = default(ServiceInstaller.SC_ACTION);
			ServiceInstaller.SC_ACTION_TYPE type = ServiceInstaller.SC_ACTION_TYPE.None;
			switch (action)
			{
			case ServiceRecoveryAction.TakeNoAction:
				type = ServiceInstaller.SC_ACTION_TYPE.None;
				break;
			case ServiceRecoveryAction.RestartTheService:
				type = ServiceInstaller.SC_ACTION_TYPE.RestartService;
				break;
			case ServiceRecoveryAction.RunAProgram:
				type = ServiceInstaller.SC_ACTION_TYPE.RunCommand;
				break;
			case ServiceRecoveryAction.RestartTheComputer:
				type = ServiceInstaller.SC_ACTION_TYPE.RebootComputer;
				break;
			}
			result.Type = type;
			result.Delay = restartServiceAfter;
			return result;
		}

		private static ServiceRecoveryAction GetServiceRecoveryAction(ServiceInstaller.SC_ACTION? action)
		{
			if (action == null)
			{
				action = new ServiceInstaller.SC_ACTION?(new ServiceInstaller.SC_ACTION
				{
					Type = ServiceInstaller.SC_ACTION_TYPE.RestartService,
					Delay = 1U
				});
			}
			ServiceRecoveryAction result = ServiceRecoveryAction.TakeNoAction;
			ServiceInstaller.SC_ACTION_TYPE? sc_ACTION_TYPE = (action != null) ? new ServiceInstaller.SC_ACTION_TYPE?(action.GetValueOrDefault().Type) : null;
			if (sc_ACTION_TYPE != null)
			{
				switch (sc_ACTION_TYPE.GetValueOrDefault())
				{
				case ServiceInstaller.SC_ACTION_TYPE.None:
					result = ServiceRecoveryAction.TakeNoAction;
					break;
				case ServiceInstaller.SC_ACTION_TYPE.RestartService:
					result = ServiceRecoveryAction.RestartTheService;
					break;
				case ServiceInstaller.SC_ACTION_TYPE.RebootComputer:
					result = ServiceRecoveryAction.RestartTheComputer;
					break;
				case ServiceInstaller.SC_ACTION_TYPE.RunCommand:
					result = ServiceRecoveryAction.RunAProgram;
					break;
				}
			}
			return result;
		}

		private const int STANDARD_RIGHTS_REQUIRED = 0xF0000;

		private const int SERVICE_WIN32_OWN_PROCESS = 0x10;

		private const int SERVICE_CONFIG_FAILURE_ACTIONS = 2;

		private const uint SERVICE_RESTART_RECOVERY_DURATION = 0xEA60U;

		private enum SC_ACTION_TYPE
		{
			None,
			RestartService,
			RebootComputer,
			RunCommand
		}

		private struct SC_ACTION
		{
			public ServiceInstaller.SC_ACTION_TYPE Type;

			public uint Delay;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		private struct SERVICE_FAILURE_ACTIONS
		{
			public int dwResetPeriod;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpRebootMsg;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpCommand;

			public int cActions;

			public IntPtr lpsaActions;
		}

		[StructLayout(LayoutKind.Sequential)]
		private class SERVICE_STATUS
		{
			public SERVICE_STATUS()
			{
			}

			public int dwServiceType;

			public ServiceState dwCurrentState;

			public int dwControlsAccepted;

			public int dwWin32ExitCode;

			public int dwServiceSpecificExitCode;

			public int dwCheckPoint;

			public int dwWaitHint;
		}
	}
}
```

**ServiceRecoveryAction.cs**

```cs
using System;

namespace ServiceInstaller
{
	public enum ServiceRecoveryAction
	{
		TakeNoAction,
		RestartTheService,
		RunAProgram,
		RestartTheComputer
	}
}
```

**ServiceRecoveryOptions.cs**

```cs
using System;

namespace ServiceInstaller
{
	public class ServiceRecoveryOptions
	{
		public ServiceRecoveryOptions()
		{
			this.FirstFailureAction = ServiceRecoveryAction.TakeNoAction;
			this.SecondFailureAction = ServiceRecoveryAction.TakeNoAction;
			this.SubsequentFailureActions = ServiceRecoveryAction.TakeNoAction;
			this.DaysToResetFailAcount = 0;
			this.MinutesToRestartService = 1;
		}

		public ServiceRecoveryAction FirstFailureAction { get; set; }

		public ServiceRecoveryAction SecondFailureAction { get; set; }

		public ServiceRecoveryAction SubsequentFailureActions { get; set; }

		public int DaysToResetFailAcount { get; set; }

		public int MinutesToRestartService { get; set; }

		public string RebootMessage { get; set; }

		public string CommandToLaunchOnFailure { get; set; }

		private bool RecoveryActionIsDefined(ServiceRecoveryAction action)
		{
			return this.FirstFailureAction == action || this.SecondFailureAction == action || this.SubsequentFailureActions == action;
		}

		public override bool Equals(object other)
		{
			return other != null && (this == other || (!(other.GetType() != typeof(ServiceRecoveryOptions)) && this.Equals((ServiceRecoveryOptions)other)));
		}

		public bool Equals(ServiceRecoveryOptions other)
		{
			return other != null && (this == other || (object.Equals(other.FirstFailureAction, this.FirstFailureAction) && object.Equals(other.SecondFailureAction, this.SecondFailureAction) && object.Equals(other.SubsequentFailureActions, this.SubsequentFailureActions) && other.DaysToResetFailAcount == this.DaysToResetFailAcount && other.MinutesToRestartService == this.MinutesToRestartService && object.Equals(other.RebootMessage, this.RebootMessage) && object.Equals(other.CommandToLaunchOnFailure, this.CommandToLaunchOnFailure)));
		}

		public override int GetHashCode()
		{
			return (((((this.FirstFailureAction.GetHashCode() * 0x18D ^ this.SecondFailureAction.GetHashCode()) * 0x18D ^ this.SubsequentFailureActions.GetHashCode()) * 0x18D ^ this.DaysToResetFailAcount) * 0x18D ^ this.MinutesToRestartService) * 0x18D ^ ((this.RebootMessage != null) ? this.RebootMessage.GetHashCode() : 0)) * 0x18D ^ ((this.CommandToLaunchOnFailure != null) ? this.CommandToLaunchOnFailure.GetHashCode() : 0);
		}

		public static ServiceRecoveryOptions FromConfiguration(RecoveryOptionsElement recoveryOptionsElement)
		{
			return new ServiceRecoveryOptions
			{
				FirstFailureAction = recoveryOptionsElement.FirstFailureAction,
				SecondFailureAction = recoveryOptionsElement.SecondFailureAction,
				SubsequentFailureActions = recoveryOptionsElement.SubsequentFailureActions,
				DaysToResetFailAcount = recoveryOptionsElement.DaysToResetFailAcount,
				CommandToLaunchOnFailure = recoveryOptionsElement.CommandToLaunchOnFailure,
				MinutesToRestartService = recoveryOptionsElement.MinutesToRestartService,
				RebootMessage = recoveryOptionsElement.RebootMessage
			};
		}
	}
}

```

**ServiceState.cs**

```cs
using System;

namespace ServiceInstaller
{
	public enum ServiceState
	{
		Unknown = -1,
		NotFound,
		Stopped,
		StartPending,
		StopPending,
		Running,
		ContinuePending,
		PausePending,
		Paused
	}
}

```

---

## Helpers

**ByteHelper.cs**

```cs
using System;
using System.IO;
using System.Linq;
using System.Text;

namespace ServiceInstaller.Helpers
{
	public class ByteHelper
	{
		public static byte[] Slice(byte[] arr, int x, int y)
		{
			return arr.Skip(x).Take(y - x).ToArray<byte>();
		}

		public static uint CalculateLittleEndianToUInt32(byte[] byteContents)
		{
			return BitConverter.ToUInt32(byteContents, 0);
		}

		public static ushort CalculateLittleEndianToUInt16(byte[] byteContents)
		{
			return BitConverter.ToUInt16(byteContents, 0);
		}

		public static byte ConvertCharToByte(char c)
		{
			string s = c.ToString();
			return Encoding.ASCII.GetBytes(s)[0];
		}

		public static string ConvertByteToString(byte[] byteContents)
		{
			if (byteContents == null || byteContents.Length == 0)
			{
				return "";
			}
			string result;
			using (StreamReader streamReader = new StreamReader(new MemoryStream(byteContents), Encoding.UTF8))
			{
				result = string.Join<char>("", streamReader.ReadToEnd().ToCharArray());
			}
			return result;
		}

		public ByteHelper()
		{
		}

		public const ushort Pe32Magic = 0x10B;

		public const ushort Pe32PlusMagic = 0x20B;

		public const int OffsetOfPEHeaderOffset = 0x3C;

		public const int CertificateTableIndex = 4;

		public const ushort CoffCharacteristicExecutableImage = 2;

		public const int CoffCharacteristicDLL = 0x2000;

		public const uint AttributeCertificateRevision = 0x200U;

		public const uint AttributeCertificateTypePKCS7SignedData = 2U;
	}
}
```

**PE32Binary.cs**

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using ServiceInstaller.Models;

namespace ServiceInstaller.Helpers
{
	public class PE32Binary
	{
		public byte[] Contents { get; set; }

		public int AttrCertOffset { get; set; }

		public int CertSizeOffset { get; set; }

		public byte[] Asn1Bytes { get; set; }

		public byte[] AppendedTag { get; set; }

		public static PE32Binary Create(byte[] byteContents)
		{
			Tuple<int, int, int> attributeCertificates = PE32Binary.GetAttributeCertificates(byteContents);
			int item = attributeCertificates.Item1;
			int item2 = attributeCertificates.Item2;
			int item3 = attributeCertificates.Item3;
			Tuple<byte[], byte[]> tuple = PE32Binary.ProcessAttributeCertificates(ByteHelper.Slice(byteContents, item, item + item2));
			byte[] item4 = tuple.Item1;
			byte[] item5 = tuple.Item2;
			return new PE32Binary
			{
				Contents = byteContents,
				AttrCertOffset = item,
				CertSizeOffset = item3,
				AppendedTag = item5,
				Asn1Bytes = item4
			};
		}

		public string GetAppendedTag()
		{
			if (this.AppendedTag.Length == 0)
			{
				return "";
			}
			return ByteHelper.ConvertByteToString(this.AppendedTag);
		}

		private static Tuple<int, int, int> GetAttributeCertificates(byte[] byteContents)
		{
			if (byteContents.Count<byte>() < 0x40)
			{
				throw new Exception("GetAttributeCertificates: Binary truncated.");
			}
			uint num = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0x3C).ToArray<byte>());
			if (num < 0U || num + 4U < num)
			{
				throw new Exception("GetAttributeCertificates: Overflow finding PE signature.");
			}
			if ((long)byteContents.Count<byte>() < (long)((ulong)(num + 4U)))
			{
				throw new Exception("GetAttributeCertificates: Binary truncated.");
			}
			byte[] array = ByteHelper.Slice(byteContents, (int)num, byteContents.Count<byte>());
			byte[] array2 = new byte[4];
			array2[0] = ByteHelper.ConvertCharToByte('P');
			array2[1] = ByteHelper.ConvertCharToByte('E');
			byte[] array3 = array2;
			byte[] array4 = ByteHelper.Slice(array, 0, 4);
			for (int i = 0; i < array4.Length; i++)
			{
				if (!array4[i].Equals(array3[i]))
				{
					throw new Exception("GetAttributeCertificates: PE header not found at expected offset.");
				}
			}
			array = ByteHelper.Slice(array, 4, array.Count<byte>());
			FileHeader fileHeader = FileHeader.Create(array.Take(0x14).ToArray<byte>(), true);
			array = ByteHelper.Slice(array, 0x14, array.Count<byte>());
			if (((int)(fileHeader.Characteristics & 2)).Equals(0))
			{
				throw new Exception("GetAttributeCertificates: File is not an executable image.");
			}
			if (((int)(fileHeader.Characteristics & 0x2000)).CompareTo(0) != 0)
			{
				throw new Exception("GetAttributeCertificates: File is a dll.");
			}
			OptionalHeader optionalHeader = OptionalHeader.Create(array.Take((int)fileHeader.SizeOfOptionalHeader).ToArray<byte>(), true);
			array = ByteHelper.Slice(array, 0x18, array.Count<byte>());
			int num2;
			if (optionalHeader.Magic == 0x20B)
			{
				num2 = 8;
			}
			else
			{
				if (optionalHeader.Magic != 0x10B)
				{
					throw new Exception("GetAttributeCertificates: Unknown magic in optional header: " + optionalHeader.Magic.ToString());
				}
				num2 = 4;
				array = ByteHelper.Slice(array, 4, array.Count<byte>());
			}
			int num3 = num2 + 0x28 + num2 * 4 + 4;
			array = ByteHelper.Slice(array, num3, array.Count<byte>());
			uint num4 = ByteHelper.CalculateLittleEndianToUInt32(array.Take(4).ToArray<byte>());
			array = ByteHelper.Slice(array, 4, array.Count<byte>());
			if (num4 > 0x1000U)
			{
				throw new Exception("GetAttributeCertificates: Invalid number of directory entries:" + num4.ToString());
			}
			num3 = 0;
			List<DataDirectory> list = new List<DataDirectory>();
			int num5 = 0;
			while ((long)num5 < (long)((ulong)num4))
			{
				DataDirectory item = DataDirectory.Create(array.Skip(num3).Take(8).ToArray<byte>(), true);
				list.Add(item);
				num3 += 8;
				num5++;
			}
			array = ByteHelper.Slice(array, num3, array.Count<byte>());
			if (num4 <= 4U)
			{
				throw new Exception("GetAttributeCertificates: File does not have enough data directory entries for a certificate");
			}
			DataDirectory dataDirectory = list[4];
			if (dataDirectory.VirtualAddress == 0U)
			{
				throw new Exception("GetAttributeCertificates: File does not have certificate data.");
			}
			uint num6 = dataDirectory.VirtualAddress + dataDirectory.Size;
			if (num6 < dataDirectory.VirtualAddress)
			{
				throw new Exception("GetAttributeCertificates: Overflow while calculating end of certificate entry");
			}
			if ((ulong)num6 != (ulong)((long)byteContents.Count<byte>()))
			{
				throw new Exception(string.Format("GetAttributeCertificates: Certificate entry is not at end of file: {0} vs {1}.", num6, byteContents.Length));
			}
			int virtualAddress = (int)dataDirectory.VirtualAddress;
			int size = (int)dataDirectory.Size;
			uint num7 = num + 4U + 0x14U + (uint)fileHeader.SizeOfOptionalHeader - 8U * (num4 - 4U) + 4U;
			if (ByteHelper.CalculateLittleEndianToUInt32(ByteHelper.Slice(byteContents, (int)num7, byteContents.Count<byte>())) != dataDirectory.Size)
			{
				throw new Exception("GetAttributeCertificates: Internal error when calculating certificate data size offset.");
			}
			return new Tuple<int, int, int>(virtualAddress, size, (int)num7);
		}

		public static string GetTenantName()
		{
			string result;
			try
			{
				result = PE32Binary.Create(File.ReadAllBytes(Application.ExecutablePath)).GetAppendedTag();
			}
			catch (Exception e)
			{
				LogUtil.LogError("Get tenant name failed. Setting it to empty", "Exception when get TenantName. " + ExceptionLoggingUtil.GetExceptionInformation(e));
				result = string.Empty;
			}
			return result;
		}

		private static int GetLengthAsn1(byte[] asn1)
		{
			int num;
			if (((int)(asn1[1] & 0x80)).Equals(0))
			{
				num = (int)(asn1[1] + 2);
			}
			else
			{
				int num2 = (int)(asn1[1] & 0x7F);
				if (num2 == 0 || num2 > 2)
				{
					throw new Exception("GetLengthAsn1: Bad number of bytes in ASN.1 length: " + num2.ToString());
				}
				if (asn1.Length < num2 + 2)
				{
					throw new Exception("GetLengthAsn1: ASN.1 structure truncated.");
				}
				num = (int)asn1[2];
				if (num2 == 2)
				{
					num <<= 8;
					num |= (int)asn1[3];
				}
				num += 2 + num2;
			}
			return num;
		}

		private static Tuple<byte[], byte[]> ProcessAttributeCertificates(byte[] attributeCertificates)
		{
			if (attributeCertificates.Count<byte>() < 8)
			{
				throw new Exception("ProcessAttributeCertificates: Attribute certificate truncated.");
			}
			ulong num = (ulong)ByteHelper.CalculateLittleEndianToUInt32(attributeCertificates.Take(4).ToArray<byte>());
			ushort num2 = ByteHelper.CalculateLittleEndianToUInt16(ByteHelper.Slice(attributeCertificates, 4, 6));
			ushort num3 = ByteHelper.CalculateLittleEndianToUInt16(ByteHelper.Slice(attributeCertificates, 6, 8));
			if (num != (ulong)((long)attributeCertificates.Length))
			{
				throw new Exception("ProcessAttributeCertificates: Multiple attribute certificates found.");
			}
			if (num2 != 0x200)
			{
				throw new Exception("ProcessAttributeCertificates: Unknown attribute certificate revision: " + num2.ToString());
			}
			if (num3 != 2)
			{
				throw new Exception("ProcessAttributeCertificates: Unknown attribute certificate type: " + num3.ToString());
			}
			byte[] array = ByteHelper.Slice(attributeCertificates, 8, attributeCertificates.Length);
			if (array.Length < 2)
			{
				throw new Exception("ProcessAttributeCertificates: ASN.1 structure truncated.");
			}
			int lengthAsn = PE32Binary.GetLengthAsn1(array);
			return new Tuple<byte[], byte[]>(ByteHelper.Slice(array, 0, lengthAsn), ByteHelper.Slice(array, lengthAsn, array.Length));
		}

		public PE32Binary()
		{
		}
	}
}

```

**ZipArchiveExtensions.cs**

```cs
using System;
using System.IO;
using System.IO.Compression;

namespace ServiceInstaller.Helpers
{
	public static class ZipArchiveExtensions
	{
		public static void ExtractToDirectory(this ZipArchive archive, string destinationDirectoryName, bool overwriteFiles)
		{
			if (!overwriteFiles)
			{
				archive.ExtractToDirectory(destinationDirectoryName);
				return;
			}
			foreach (ZipArchiveEntry zipArchiveEntry in archive.Entries)
			{
				string text = Path.Combine(destinationDirectoryName, zipArchiveEntry.FullName);
				string directoryName = Path.GetDirectoryName(text);
				if (!Directory.Exists(directoryName))
				{
					Directory.CreateDirectory(directoryName);
				}
				if (zipArchiveEntry.Name != "")
				{
					zipArchiveEntry.ExtractToFile(text, true);
				}
			}
		}
	}
}

```

---

## Models

**DataDirectory.cs**

```cs
using System;
using System.Linq;
using ServiceInstaller.Helpers;

namespace ServiceInstaller.Models
{
	public class DataDirectory
	{
		public uint VirtualAddress { get; set; }

		public uint Size { get; set; }

		public static DataDirectory Create(byte[] byteContents, bool isLittleEndian = false)
		{
			if (byteContents.Count<byte>() != 8)
			{
				return null;
			}
			if (!isLittleEndian)
			{
				throw new Exception("Unsupported operation");
			}
			return new DataDirectory
			{
				VirtualAddress = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0).Take(4).ToArray<byte>()),
				Size = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(4).Take(4).ToArray<byte>())
			};
		}

		public DataDirectory()
		{
		}
	}
}
```

**FileHeader.cs**

```cs
using System;
using System.Linq;
using ServiceInstaller.Helpers;

namespace ServiceInstaller.Models
{
	public class FileHeader
	{
		public ushort Machine { get; set; }

		public ushort NumberOfSections { get; set; }

		public uint TimeDateStamp { get; set; }

		public uint PointerForSymbolTable { get; set; }

		public uint NumberOfSymbols { get; set; }

		public ushort SizeOfOptionalHeader { get; set; }

		public ushort Characteristics { get; set; }

		public static FileHeader Create(byte[] byteContents, bool isLittleEndian = false)
		{
			if (byteContents.Count<byte>() != 0x14)
			{
				return null;
			}
			if (!isLittleEndian)
			{
				throw new Exception("Unsupported operation");
			}
			return new FileHeader
			{
				Machine = ByteHelper.CalculateLittleEndianToUInt16(byteContents.Skip(0).Take(2).ToArray<byte>()),
				NumberOfSections = ByteHelper.CalculateLittleEndianToUInt16(byteContents.Skip(2).Take(2).ToArray<byte>()),
				TimeDateStamp = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(4).Take(4).ToArray<byte>()),
				PointerForSymbolTable = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(8).Take(4).ToArray<byte>()),
				NumberOfSymbols = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0xC).Take(4).ToArray<byte>()),
				SizeOfOptionalHeader = ByteHelper.CalculateLittleEndianToUInt16(byteContents.Skip(0x10).Take(2).ToArray<byte>()),
				Characteristics = ByteHelper.CalculateLittleEndianToUInt16(byteContents.Skip(0x12).Take(2).ToArray<byte>())
			};
		}

		public FileHeader()
		{
		}

		public const int Size = 0x14;
	}
}
```

**OptionalHeader.cs**

```cs
using System;
using System.Linq;
using ServiceInstaller.Helpers;

namespace ServiceInstaller.Models
{
	internal class OptionalHeader
	{
		public ushort Magic { get; set; }

		public byte MajorLinkerVersion { get; set; }

		public byte MinorLinkerVersion { get; set; }

		public uint SizeOfCode { get; set; }

		public uint SizeOfInitializedData { get; set; }

		public uint SizeOfUninitializedData { get; set; }

		public uint AddressOfEntryPoint { get; set; }

		public uint BaseOfCode { get; set; }

		public static OptionalHeader Create(byte[] byteContents, bool isLittleEndian = false)
		{
			if (byteContents.Count<byte>() < 0x18)
			{
				return null;
			}
			if (!isLittleEndian)
			{
				throw new Exception("Unsupported operation");
			}
			return new OptionalHeader
			{
				Magic = ByteHelper.CalculateLittleEndianToUInt16(byteContents.Skip(0).Take(2).ToArray<byte>()),
				MajorLinkerVersion = byteContents[2],
				MinorLinkerVersion = byteContents[3],
				SizeOfCode = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(4).Take(4).ToArray<byte>()),
				SizeOfInitializedData = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(8).Take(4).ToArray<byte>()),
				SizeOfUninitializedData = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0xC).Take(4).ToArray<byte>()),
				AddressOfEntryPoint = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0x10).Take(4).ToArray<byte>()),
				BaseOfCode = ByteHelper.CalculateLittleEndianToUInt32(byteContents.Skip(0x14).Take(4).ToArray<byte>())
			};
		}

		public OptionalHeader()
		{
		}

		public const int Size = 0x18;
	}
}
```

---

## Properties

**AssemblyInfo.cs**

> Configuration / Compiler genreated.

**Resources.cs**

> Comiler generated

**Resources.resources**

> favicon

**Settings.Designer.cs**

> Compiler generated

**Settings.Settings**

> Compiler generated
