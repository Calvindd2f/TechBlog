---
title: Configuration Daily Apps
description: Configurations for apps I use every day.
pubDate: Oct 03 2024
heroImage: /public/img/blog-placeholder-about.jpg
---




# Obsidian
> THEME : ATOM
> 
> PLUGINS: 
> Advanced Codeblock
> Auto Reading Mode
> Excalidraw
> Explorer Hider
> Hover Editor
> Make.md
> Shiki Highlighter

# Snagget
> Default configuration
> Replaces the Snipping Tool for Print Screen

# PowerShell 7.4.5


```powershell
# $Profile
. C:\Dev\STL\out\x64\set_environment.ps1
$env:appCertificate=
$env:appID=''
$env:appThmb=''
$env:appSecret=
$env:tenantID=
#--------ENDOF--------#
function add-path($path){
  [void]($env:PATH += ";$path")
}
function Set-Path([string]$Path){
    try{[System.Environment]::SetEnvironmentVariable("$env:Path",";$path")}
    catch{[null]$except=[Internal.Console]::WriteLine('You have fucked up');sleep 2;get-error;exit}
   
    if(!($except)){$msg=[Internal.Console]::WriteLine("Directory and child items added to '`$env:path`' = $Path")}
    return $msg
}
<#-------Notice------#
    #read_only

    New-Variable -Name appID -Value $env:appID -Description 'Graph Application ID' -Option Constant -Visibility Public -Force
    New-Variable -Name appSecret -Value $env:appSecret -Description 'Graph Application secret' -Option Constant -Visibility Public -Force
    New-Variable -Name tenantID -Value $env:tenantID -Description 'Tenant ID where Graph/App Registration belongs' -Option Constant -Visibility Public -Force
    New-Variable -Name appThumb -Value $env:appThumb -Description 'Graph Application Certificate Thumbprint' -Option Constant -Visibility Public -Force

    New-Variable -Name "exo_token" -Value "$EXO_Api_Token_Client" -Description 'contexts sensitivity exchange token' -Visibility Public -Force
    New-Variable -Name "msgraph_token" -Value "$MSGRAPH_Api_Token_Client"  -Description 'contexts sensitivity exchange token' -Visibility Public -Force
    New-Variable -Name "tenant_id" -Value "$Ctx_Client_MSTenant_Id"  -Description 'context sensitive tenant ID' -Visibility Public -Force
    New-Variable -Name "tenant_name" -Value "$Ctx_Client_MSTenant_Name"  -Description 'context sensitive' -Visibility Public -Force
#>
<# read_only
    ####################################################
    ##########  INPUT
    #####################################################

    #appID		= "$appID";
    #appSecret 	= "$appSecret";
    #appCertThumb = "$appThumb";
    #tenantID 	= "$tenantID";

    ####################################################
    ##########  OUTPUT
    #####################################################

    $variableProps = @{
        result = $null;
        msgraph_token = $null;
        exo_token = $null;
        tenant_id=$null;
        tenant_name=$null;
        appID=$null;
        appSecret=$null;
        appCertThumb=$null;
        tenantID=$null;
    }

    $outputProps = @{
       out = $(New-Object psobject -Property $variableProps);
       success = $false;
    }

    $activityOutput = New-Object psobject -Property $outputProps;

    #/read_only
#>
#-------------------------------------------------
# env=variable define.
$env:AppId = 
$env:TenantId = 
$env:AppSecret = 
$env:AppCertificateThumbprint = 
$env:AppCertificateInfo = 
$env:AppCertificatePEM = 
#-------------------------------------------------
# openai key declaration..
$env:OpenAI_SECRET_RWX=
$env:OpenAI_SECRET_RO=
#-------------------------------------------------
# elevenlabs keys
$env:XI_API_KEY = 
$XI_URI = 
#-------------------------------------------------
$env:src='C:\src'
$env:dev='C:\dev'
$env:packages="$env:src\packages"
$env:STL="C:\src\stl\stl"
#-------------------------------------------------
function prompt {
    # The following block is surrounded by two delimiters.
    # These delimiters must not be modified. Thanks.
    # START KALI CONFIG VARIABLES
    $PROMPT_ALTERNATIVE='twoline'
    $NEWLINE_BEFORE_PROMPT='yes'
    # STOP KALI CONFIG VARIABLES

    $esc = [char]27
    $bell = [char]7
    $bold = "$esc[1m"
    $reset = "$esc[0m"
    If ($NEWLINE_BEFORE_PROMPT -eq 'yes') { Write-Host }
    If ($PROMPT_ALTERNATIVE -eq 'twoline') {
        Write-Host "ΓöîΓöÇΓöÇ(" -NoNewLine -ForegroundColor Blue
        Write-Host "${bold}$([environment]::username)πë┐$([system.environment]::MachineName)${reset}" -NoNewLine -ForegroundColor Magenta
        Write-Host ")-[" -NoNewLine -ForegroundColor Blue
        Write-Host "${bold}$(Get-Location)${reset}" -NoNewLine -ForegroundColor White
        Write-Host "]" -ForegroundColor Blue
        Write-Host "ΓööΓöÇ" -NoNewLine -ForegroundColor Blue
        Write-Host "${bold}PS>${reset}" -NoNewLine -ForegroundColor Blue
    } Else {
        Write-Host "${bold}PS " -NoNewLine -ForegroundColor Blue
        Write-Host "$([environment]::username)@$([system.environment]::MachineName) " -NoNewLine -ForegroundColor Magenta
        Write-Host "$(Get-Location)>${reset}" -NoNewLine -ForegroundColor Blue
    }
    # Terminal title
    [console]::WriteLine("${esc}]0;PS> $([environment]::username)@$([system.environment]::MachineName)= $(Get-Location)${bell}");
    return " "
}
#--------------------------------------------------
function Get-Assemblies {
    Process {
        [AppDomain]::CurrentDomain.GetAssemblies() | ForEach-Object {
            New-Object -TypeName PSObject -Property @{
                FullName            = $_.FullName
                Location            = $_.Location
                GlobalAssemblyCache = $_.GlobalAssemblyCache
                CodeBase            = $_.CodeBase
                ImageRuntimeVersion = $_.ImageRuntimeVersion
                Module              = $_.ManifestModule
                ExportedTypes       = $_.GetExportedTypes() | ForEach-Object { $_.FullName }
                Methods             = $_.GetTypes() | ForEach-Object { $_.GetMethods() } | ForEach-Object { $_.Native}
            }
        }
    }
}
function Optimize-Assemblies {
    [CmdletBinding()]
    param (
        [string]$AssemblyFilter = "Microsoft.PowerShell.",
        [string]$Activity = "Native Image Installation"
    )

    try {
        # Try to get ngen.exe from the Visual Studio environment
        $ngenPath = Get-Command ngen.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

        # If not found, fallback to .NET Framework directory
        if (-not $ngenPath) {
            $ngenPath = 'C:\WINDOWS\Microsoft.NET\Framework64\v4.0.30319\ngen.exe'
        }

        # Check if ngen.exe exists
        if (-not (Test-Path $ngenPath)) {
            Write-Error "Ngen.exe not found. Make sure .NET Framework is installed and the Visual Studio environment is loaded."
            return
        }

        Write-Verbose "Using ngen.exe from= $ngenPath"

        # Get a list of loaded assemblies
        $assemblies = [AppDomain]::CurrentDomain.GetAssemblies()

        # Filter assemblies based on the provided filter
        $filteredAssemblies = $assemblies | Where-Object { $_.FullName -like "$AssemblyFilter*" }

        if ($filteredAssemblies.Count -eq 0) {
            Write-Warning "No matching assemblies found for optimization."
            return
        }

        $totalAssemblies = $filteredAssemblies.Count
        $currentAssembly = 0

        foreach ($assembly in $filteredAssemblies) {
            $currentAssembly++
            
            # Get the name of the assembly
            $name = [System.IO.Path]::GetFileName($assembly.Location)

            # Display progress
            $percentComplete = ($currentAssembly / $totalAssemblies) * 100
            Write-Progress -Activity $Activity -Status "Optimizing $name" -PercentComplete $percentComplete

            # Run ngen install
            $output = & $ngenPath install $assembly.Location 2>&1

            # Check for errors
            if ($LASTEXITCODE -ne 0) {
                Write-Warning "Error optimizing $name. Error= $output"
            }
            else {
                Write-Verbose "Successfully optimized $name"
            }
        }
    }
    catch {
        Write-Error "An error occurred= $_"
    }
    finally {
        Write-Progress -Activity $Activity -Completed
    }
}
Function Get-TenantID{
    [CmdletBinding()]
    [OutputType([string])]
    PARAM (
        [Parameter(ParameterSetName = 'Domain', Position = 0, Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [String]
        $Domain,

        [Parameter(ParameterSetName = 'Email', Position = 1, Mandatory = $false)]
        [ValidateScript({
            try
            {
                [void]([mailaddress]$Email)
                return $true
            }
            catch
            {
                return $false
            }
        })]
        [String]
        $Email,

        [Parameter(ParameterSetName = 'TenantID', Position = 2, Mandatory = $false)]
        [ValidateScript({
            try
            {
                [void]([System.Guid]::Parse($_))
                $true
            }
            catch
            {
                $false
            }
        })]
        [Alias('tID')]
        [String]
        $TenantID,

        [Parameter()]
        [switch]
        $CurrentContext,

        [Parameter()]
        [Alias("dump")]
        [switch]
        $Full
        )

        if ([switch]$CurrentContext)
        {
            if((Get-MgContext) -notlike $null)
            {
                $tenantID = (Get-MgContext).Account.Split('@')[1]
                return $tenantID
            }
            else
            {
                break
            }
        }

        if ($domain)
        {
            (Invoke-WebRequest https://login.windows.net/${domain}/.well-known/openid-configuration | ConvertFrom-Json).token_endpoint.Split('/')[3]
        } elseif ($email)
        {
            $domain = $email.split('@')[1];
            (Invoke-WebRequest https://login.windows.net/${domain}/.well-known/openid-configuration | ConvertFrom-Json).token_endpoint.Split('/')[3]
        } else  {
            throw [System.Exception]::new("You have not inputted a valid domain or email address")
        }

        if([switch]$Full)
        {
            if ($PScmdlet.ParameterSetName -eq 'ByEmail')
            {
                $URI = "https://login.windows.net/$Email/.well-known/openid-configuration"
            }
            else
            {
                $URI = "https://login.windows.net/$Domain/.well-known/openid-configuration"
            }
            $ret = Invoke-WebRequest -UseBasicParsing -Uri $URI -Method Get |  ConvertFrom-Json
            return $ret
        }
}
Function Write-ApplicationLog([string]$log, [switch]$show, [string[]]$logfile='Logfile.log')
{
    [string]$logtime = $((Get-Date -Format "[dd/MM/yyyy HH=mm=ss zz] |").ToString())
    foreach($line in $($log -split "`n"))
    {
        if($VerbosePreference -eq 'Continue' -or $show -eq $true)
        { [console]::writeline("$logtime $line") };

        [string]::new("$logtime $line") >> "$env:TEMP\$logfile"
    }
}
# Import Binary Cmdlets
Import-Module -Path 'C:\Users\c\Desktop\Functions\CS\logging\bin\Debug\net8.0\Logging.dll'
Function Load-PowerShellRuntimeExtensions
{
    [void](add-type -Path 'C:\Users\c\Desktop\pia_disassemble\OrchestratorAgentXcompressed\OrchestratorAgent - Copy\PowerShellRuntimeExtensions20.dll')
    function ConvertFrom-Json20([object] $inputObject) {
        $err = $null;
        return [PowerShellRuntimeExtensions.JsonObject]::ConvertFromJson($inputObject, $false, 4, [ref]$err);
    }
    function ConvertTo-Json20([object] $inputObject, $depth = 5) {
        $ctx = New-Object Pia.PowerShellRuntimeExtensions.ConvertToJsonContext $depth, $false, $false, "Default";
        return [PowerShellRuntimeExtensions.JsonObject]::ConvertToJson($inputObject, [ref]$ctx);
    }
    [void](if ((Get-Command "ConvertTo-Json" -errorAction SilentlyContinue) -eq $null) { New-Alias -Name "ConvertTo-JSON" -Value "ConvertTo-Json20" -Scope Global })
    [void](if ((Get-Command "ConvertFrom-Json" -errorAction SilentlyContinue) -eq $null) { New-Alias -Name "ConvertFrom-JSON" -Value "ConvertFrom-Json20" -Scope Global })
}
function const([string]$Name, [string]$Value)
{
    New-Variable -Name $Name -Value $Value -Option Constant -Force -Scope Script
}
function print([string]$InputObject)
{
    [console]::writeline([string]$InputObject)
}
function env
{
    [System.Environment]::GetEnvironmentVariables()|convertto-json|convertfrom-json;
}
class credentials
{
    [pscustomobject]$app_support=[pscustomobject]@{
        appID=''
        secret=''
        thumbprint=''
        tenantID=''
    }
    [PSCustomObject]$SENDGRID = [PSCustomObject]@{
        app_support_com     =  ''
        msgraph_dev   = ''
        api_key = ''
    }
}
$app_support=[credentials]::new().app_support
return $app_support;
#--------------------------------------------------
$scope=@('Directory.AccessAsUser.All','Mail.Read','offline_access','AppCatalog.ReadWrite.All','AuditLog.Read.All','DeviceManagementConfiguration.ReadWrite.All','DeviceManagementRBAC.ReadWrite.All','DeviceManagementManagedDevices.PrivilegedOperations.All','Calendars.ReadWrite.Shared,User.Read','Group.ReadWrite.All','Mail.Send','IdentityRiskEvent.Read.All','AppRoleAssignment.ReadWrite.All','BitlockerKey.Read.All','UserAuthenticationMethod.ReadWrite.All','ConsentRequest.ReadWrite.All','Chat.ReadWrite','ChatMessage.Send,ChannelMessage.Read.All,Device.ReadWrite.All','User.ReadWrite.All','UserAuthenticationMethod.ReadWrite.All','WindowsUpdates.ReadWrite.All','Directory.ReadWrite.All','Group.ReadWrite.All','DeviceManagementServiceConfig.ReadWrite.All','TeamMember.ReadWrite.All','Organization.ReadWrite.All','ConsentRequest.ReadWrite.All','AppRoleAssignment.ReadWrite.All','User.ManageIdentities.All','MailboxSettings.ReadWrite','ChannelMember.ReadWrite.All','RoleManagement.ReadWrite.Directory,GroupMember.ReadWrite.All','IdentityRiskEvent.Read.All,AdministrativeUnit.ReadWrite.All','AuditLog.Read.All','DeviceManagementConfiguration.ReadWrite.All','DeviceManagementManagedDevices.PrivilegedOperations.All','ServiceHealth.Read.All','DeviceManagementRBAC.ReadWrite.All')
#--------------------------------------------------
[void](& 'C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat');
[void](& 'C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat');
[void](& 'C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\vcvars32.bat');
[void](& 'C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\vcvars32.bat');
[void](& "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\vcvarsphoneall.bat");
[void](&{Import-Module "C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\Tools\Microsoft.VisualStudio.DevShell.dll"; Enter-VsDevShell 132962a2 -SkipAutomaticLocation -DevCmdArguments "-arch=x64 -host_arch=x64"});
#--------------------------------------------------
# NOTE= Using the sysinternals strings -n7 when using strings on windows
#--------------------------------------------------
$modules=@('PSScriptAnalyzer','Pester','platyPS','psake');
foreach ($m in $modules)
{
    [void](Import-Module -Force -Scope CurrentUser -Name $m)
}
[System.GC]::Collect();
[System.GC]::WaitForPendingFinalizers();
$env:HOSTS='c:\Windows\System32\Drivers\etc\hosts'
```
